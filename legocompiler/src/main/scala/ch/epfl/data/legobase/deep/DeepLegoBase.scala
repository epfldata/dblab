/* Generated by AutoLifter Â© 2014 */

package ch.epfl.data
package legobase
package deep

import scalalib._
import pardis.ir._
import pardis.ir.pardisTypeImplicits._
import pardis.deep.scalalib._

trait GroupByClassOps extends Base { this: DeepDSL =>
  implicit class GroupByClassRep(self: Rep[GroupByClass]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = groupByClassGetField(self, key)
    def L_LINESTATUS: Rep[Character] = groupByClass_Field_L_LINESTATUS(self)
    def L_RETURNFLAG: Rep[Character] = groupByClass_Field_L_RETURNFLAG(self)
  }
  object GroupByClass {

  }
  // constructors
  def __newGroupByClass(L_RETURNFLAG: Rep[Character], L_LINESTATUS: Rep[Character]): Rep[GroupByClass] = groupByClassNew(L_RETURNFLAG, L_LINESTATUS)
  // case classes
  case class GroupByClassNew(L_RETURNFLAG: Rep[Character], L_LINESTATUS: Rep[Character]) extends ConstructorDef[GroupByClass](List(), "GroupByClass", List(List(L_RETURNFLAG, L_LINESTATUS))) {
    override def curriedConstructor = (copy _).curried
  }

  case class GroupByClassGetField(self: Rep[GroupByClass], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class GroupByClass_Field_L_LINESTATUS(self: Rep[GroupByClass]) extends FieldDef[Character](self, "L_LINESTATUS") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class GroupByClass_Field_L_RETURNFLAG(self: Rep[GroupByClass]) extends FieldDef[Character](self, "L_RETURNFLAG") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def groupByClassNew(L_RETURNFLAG: Rep[Character], L_LINESTATUS: Rep[Character]): Rep[GroupByClass] = GroupByClassNew(L_RETURNFLAG, L_LINESTATUS)
  def groupByClassGetField(self: Rep[GroupByClass], key: Rep[String]): Rep[Option[Any]] = GroupByClassGetField(self, key)
  def groupByClass_Field_L_LINESTATUS(self: Rep[GroupByClass]): Rep[Character] = GroupByClass_Field_L_LINESTATUS(self)
  def groupByClass_Field_L_RETURNFLAG(self: Rep[GroupByClass]): Rep[Character] = GroupByClass_Field_L_RETURNFLAG(self)
  type GroupByClass = ch.epfl.data.legobase.queryengine.GroupByClass
  case object GroupByClassType extends TypeRep[GroupByClass] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = GroupByClassType
    val name = "GroupByClass"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[GroupByClass]
  }
  implicit val typeGroupByClass = GroupByClassType
}
trait GroupByClassImplicits { this: GroupByClassComponent =>
  // Add implicit conversions here!
}
trait GroupByClassImplementations { self: DeepDSL =>

}
trait GroupByClassComponent extends GroupByClassOps with GroupByClassImplicits { self: DeepDSL => }

trait Q3GRPRecordOps extends Base { this: DeepDSL =>
  implicit class Q3GRPRecordRep(self: Rep[Q3GRPRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = q3GRPRecordGetField(self, key)
    def O_SHIPPRIORITY: Rep[Int] = q3GRPRecord_Field_O_SHIPPRIORITY(self)
    def O_ORDERDATE: Rep[Long] = q3GRPRecord_Field_O_ORDERDATE(self)
    def L_ORDERKEY: Rep[Int] = q3GRPRecord_Field_L_ORDERKEY(self)
  }
  object Q3GRPRecord {

  }
  // constructors
  def __newQ3GRPRecord(L_ORDERKEY: Rep[Int], O_ORDERDATE: Rep[Long], O_SHIPPRIORITY: Rep[Int]): Rep[Q3GRPRecord] = q3GRPRecordNew(L_ORDERKEY, O_ORDERDATE, O_SHIPPRIORITY)
  // case classes
  case class Q3GRPRecordNew(L_ORDERKEY: Rep[Int], O_ORDERDATE: Rep[Long], O_SHIPPRIORITY: Rep[Int]) extends ConstructorDef[Q3GRPRecord](List(), "Q3GRPRecord", List(List(L_ORDERKEY, O_ORDERDATE, O_SHIPPRIORITY))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q3GRPRecordGetField(self: Rep[Q3GRPRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class Q3GRPRecord_Field_O_SHIPPRIORITY(self: Rep[Q3GRPRecord]) extends FieldDef[Int](self, "O_SHIPPRIORITY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q3GRPRecord_Field_O_ORDERDATE(self: Rep[Q3GRPRecord]) extends FieldDef[Long](self, "O_ORDERDATE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class Q3GRPRecord_Field_L_ORDERKEY(self: Rep[Q3GRPRecord]) extends FieldDef[Int](self, "L_ORDERKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def q3GRPRecordNew(L_ORDERKEY: Rep[Int], O_ORDERDATE: Rep[Long], O_SHIPPRIORITY: Rep[Int]): Rep[Q3GRPRecord] = Q3GRPRecordNew(L_ORDERKEY, O_ORDERDATE, O_SHIPPRIORITY)
  def q3GRPRecordGetField(self: Rep[Q3GRPRecord], key: Rep[String]): Rep[Option[Any]] = Q3GRPRecordGetField(self, key)
  def q3GRPRecord_Field_O_SHIPPRIORITY(self: Rep[Q3GRPRecord]): Rep[Int] = Q3GRPRecord_Field_O_SHIPPRIORITY(self)
  def q3GRPRecord_Field_O_ORDERDATE(self: Rep[Q3GRPRecord]): Rep[Long] = Q3GRPRecord_Field_O_ORDERDATE(self)
  def q3GRPRecord_Field_L_ORDERKEY(self: Rep[Q3GRPRecord]): Rep[Int] = Q3GRPRecord_Field_L_ORDERKEY(self)
  type Q3GRPRecord = ch.epfl.data.legobase.queryengine.Q3GRPRecord
  case object Q3GRPRecordType extends TypeRep[Q3GRPRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = Q3GRPRecordType
    val name = "Q3GRPRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[Q3GRPRecord]
  }
  implicit val typeQ3GRPRecord = Q3GRPRecordType
}
trait Q3GRPRecordImplicits { this: Q3GRPRecordComponent =>
  // Add implicit conversions here!
}
trait Q3GRPRecordImplementations { self: DeepDSL =>

}
trait Q3GRPRecordComponent extends Q3GRPRecordOps with Q3GRPRecordImplicits { self: DeepDSL => }

trait AGGRecordOps extends Base { this: DeepDSL =>
  implicit class AGGRecordRep[B](self: Rep[AGGRecord[B]])(implicit typeB: TypeRep[B]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = aGGRecordGetField[B](self, key)(typeB)
    def aggs: Rep[Array[Double]] = aGGRecord_Field_Aggs[B](self)(typeB)
    def key: Rep[B] = aGGRecord_Field_Key[B](self)(typeB)
  }
  object AGGRecord {

  }
  // constructors
  def __newAGGRecord[B](key: Rep[B], aggs: Rep[Array[Double]])(implicit typeB: TypeRep[B]): Rep[AGGRecord[B]] = aGGRecordNew[B](key, aggs)(typeB)
  // case classes
  case class AGGRecordNew[B](key: Rep[B], aggs: Rep[Array[Double]])(implicit val typeB: TypeRep[B]) extends ConstructorDef[AGGRecord[B]](List(typeB), "AGGRecord", List(List(key, aggs))) {
    override def curriedConstructor = (copy[B] _).curried
  }

  case class AGGRecordGetField[B](self: Rep[AGGRecord[B]], key: Rep[String])(implicit val typeB: TypeRep[B]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy[B] _).curried
  }

  case class AGGRecord_Field_Aggs[B](self: Rep[AGGRecord[B]])(implicit val typeB: TypeRep[B]) extends FieldDef[Array[Double]](self, "aggs") {
    override def curriedConstructor = (copy[B] _)
    override def isPure = true

  }

  case class AGGRecord_Field_Key[B](self: Rep[AGGRecord[B]])(implicit val typeB: TypeRep[B]) extends FieldDef[B](self, "key") {
    override def curriedConstructor = (copy[B] _)
    override def isPure = true

  }

  // method definitions
  def aGGRecordNew[B](key: Rep[B], aggs: Rep[Array[Double]])(implicit typeB: TypeRep[B]): Rep[AGGRecord[B]] = AGGRecordNew[B](key, aggs)
  def aGGRecordGetField[B](self: Rep[AGGRecord[B]], key: Rep[String])(implicit typeB: TypeRep[B]): Rep[Option[Any]] = AGGRecordGetField[B](self, key)
  def aGGRecord_Field_Aggs[B](self: Rep[AGGRecord[B]])(implicit typeB: TypeRep[B]): Rep[Array[Double]] = AGGRecord_Field_Aggs[B](self)
  def aGGRecord_Field_Key[B](self: Rep[AGGRecord[B]])(implicit typeB: TypeRep[B]): Rep[B] = AGGRecord_Field_Key[B](self)
  type AGGRecord[B] = ch.epfl.data.legobase.queryengine.AGGRecord[B]
  case class AGGRecordType[B](typeB: TypeRep[B]) extends TypeRep[AGGRecord[B]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = AGGRecordType(newArguments(0).asInstanceOf[TypeRep[_]])
    private implicit val tagB = typeB.typeTag
    val name = s"AGGRecord[${typeB.name}]"
    val typeArguments = List(typeB)
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[AGGRecord[B]]
  }
  implicit def typeAGGRecord[B: TypeRep] = AGGRecordType(implicitly[TypeRep[B]])
}
trait AGGRecordImplicits { this: AGGRecordComponent =>
  // Add implicit conversions here!
}
trait AGGRecordImplementations { self: DeepDSL =>

}
trait AGGRecordComponent extends AGGRecordOps with AGGRecordImplicits { self: DeepDSL => }

trait LINEITEMRecordOps extends Base { this: DeepDSL =>
  implicit class LINEITEMRecordRep(self: Rep[LINEITEMRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = lINEITEMRecordGetField(self, key)
    def L_COMMENT: Rep[OptimalString] = lINEITEMRecord_Field_L_COMMENT(self)
    def L_SHIPMODE: Rep[OptimalString] = lINEITEMRecord_Field_L_SHIPMODE(self)
    def L_SHIPINSTRUCT: Rep[OptimalString] = lINEITEMRecord_Field_L_SHIPINSTRUCT(self)
    def L_RECEIPTDATE: Rep[Long] = lINEITEMRecord_Field_L_RECEIPTDATE(self)
    def L_COMMITDATE: Rep[Long] = lINEITEMRecord_Field_L_COMMITDATE(self)
    def L_SHIPDATE: Rep[Long] = lINEITEMRecord_Field_L_SHIPDATE(self)
    def L_LINESTATUS: Rep[Character] = lINEITEMRecord_Field_L_LINESTATUS(self)
    def L_RETURNFLAG: Rep[Character] = lINEITEMRecord_Field_L_RETURNFLAG(self)
    def L_TAX: Rep[Double] = lINEITEMRecord_Field_L_TAX(self)
    def L_DISCOUNT: Rep[Double] = lINEITEMRecord_Field_L_DISCOUNT(self)
    def L_EXTENDEDPRICE: Rep[Double] = lINEITEMRecord_Field_L_EXTENDEDPRICE(self)
    def L_QUANTITY: Rep[Double] = lINEITEMRecord_Field_L_QUANTITY(self)
    def L_LINENUMBER: Rep[Int] = lINEITEMRecord_Field_L_LINENUMBER(self)
    def L_SUPPKEY: Rep[Int] = lINEITEMRecord_Field_L_SUPPKEY(self)
    def L_PARTKEY: Rep[Int] = lINEITEMRecord_Field_L_PARTKEY(self)
    def L_ORDERKEY: Rep[Int] = lINEITEMRecord_Field_L_ORDERKEY(self)
  }
  object LINEITEMRecord {

  }
  // constructors
  def __newLINEITEMRecord(L_ORDERKEY: Rep[Int], L_PARTKEY: Rep[Int], L_SUPPKEY: Rep[Int], L_LINENUMBER: Rep[Int], L_QUANTITY: Rep[Double], L_EXTENDEDPRICE: Rep[Double], L_DISCOUNT: Rep[Double], L_TAX: Rep[Double], L_RETURNFLAG: Rep[Character], L_LINESTATUS: Rep[Character], L_SHIPDATE: Rep[Long], L_COMMITDATE: Rep[Long], L_RECEIPTDATE: Rep[Long], L_SHIPINSTRUCT: Rep[OptimalString], L_SHIPMODE: Rep[OptimalString], L_COMMENT: Rep[OptimalString]): Rep[LINEITEMRecord] = lINEITEMRecordNew(L_ORDERKEY, L_PARTKEY, L_SUPPKEY, L_LINENUMBER, L_QUANTITY, L_EXTENDEDPRICE, L_DISCOUNT, L_TAX, L_RETURNFLAG, L_LINESTATUS, L_SHIPDATE, L_COMMITDATE, L_RECEIPTDATE, L_SHIPINSTRUCT, L_SHIPMODE, L_COMMENT)
  // case classes
  case class LINEITEMRecordNew(L_ORDERKEY: Rep[Int], L_PARTKEY: Rep[Int], L_SUPPKEY: Rep[Int], L_LINENUMBER: Rep[Int], L_QUANTITY: Rep[Double], L_EXTENDEDPRICE: Rep[Double], L_DISCOUNT: Rep[Double], L_TAX: Rep[Double], L_RETURNFLAG: Rep[Character], L_LINESTATUS: Rep[Character], L_SHIPDATE: Rep[Long], L_COMMITDATE: Rep[Long], L_RECEIPTDATE: Rep[Long], L_SHIPINSTRUCT: Rep[OptimalString], L_SHIPMODE: Rep[OptimalString], L_COMMENT: Rep[OptimalString]) extends ConstructorDef[LINEITEMRecord](List(), "LINEITEMRecord", List(List(L_ORDERKEY, L_PARTKEY, L_SUPPKEY, L_LINENUMBER, L_QUANTITY, L_EXTENDEDPRICE, L_DISCOUNT, L_TAX, L_RETURNFLAG, L_LINESTATUS, L_SHIPDATE, L_COMMITDATE, L_RECEIPTDATE, L_SHIPINSTRUCT, L_SHIPMODE, L_COMMENT))) {
    override def curriedConstructor = (copy _).curried
  }

  case class LINEITEMRecordGetField(self: Rep[LINEITEMRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class LINEITEMRecord_Field_L_COMMENT(self: Rep[LINEITEMRecord]) extends FieldDef[OptimalString](self, "L_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_SHIPMODE(self: Rep[LINEITEMRecord]) extends FieldDef[OptimalString](self, "L_SHIPMODE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_SHIPINSTRUCT(self: Rep[LINEITEMRecord]) extends FieldDef[OptimalString](self, "L_SHIPINSTRUCT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_RECEIPTDATE(self: Rep[LINEITEMRecord]) extends FieldDef[Long](self, "L_RECEIPTDATE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_COMMITDATE(self: Rep[LINEITEMRecord]) extends FieldDef[Long](self, "L_COMMITDATE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_SHIPDATE(self: Rep[LINEITEMRecord]) extends FieldDef[Long](self, "L_SHIPDATE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_LINESTATUS(self: Rep[LINEITEMRecord]) extends FieldDef[Character](self, "L_LINESTATUS") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_RETURNFLAG(self: Rep[LINEITEMRecord]) extends FieldDef[Character](self, "L_RETURNFLAG") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_TAX(self: Rep[LINEITEMRecord]) extends FieldDef[Double](self, "L_TAX") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_DISCOUNT(self: Rep[LINEITEMRecord]) extends FieldDef[Double](self, "L_DISCOUNT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_EXTENDEDPRICE(self: Rep[LINEITEMRecord]) extends FieldDef[Double](self, "L_EXTENDEDPRICE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_QUANTITY(self: Rep[LINEITEMRecord]) extends FieldDef[Double](self, "L_QUANTITY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_LINENUMBER(self: Rep[LINEITEMRecord]) extends FieldDef[Int](self, "L_LINENUMBER") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_SUPPKEY(self: Rep[LINEITEMRecord]) extends FieldDef[Int](self, "L_SUPPKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_PARTKEY(self: Rep[LINEITEMRecord]) extends FieldDef[Int](self, "L_PARTKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class LINEITEMRecord_Field_L_ORDERKEY(self: Rep[LINEITEMRecord]) extends FieldDef[Int](self, "L_ORDERKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def lINEITEMRecordNew(L_ORDERKEY: Rep[Int], L_PARTKEY: Rep[Int], L_SUPPKEY: Rep[Int], L_LINENUMBER: Rep[Int], L_QUANTITY: Rep[Double], L_EXTENDEDPRICE: Rep[Double], L_DISCOUNT: Rep[Double], L_TAX: Rep[Double], L_RETURNFLAG: Rep[Character], L_LINESTATUS: Rep[Character], L_SHIPDATE: Rep[Long], L_COMMITDATE: Rep[Long], L_RECEIPTDATE: Rep[Long], L_SHIPINSTRUCT: Rep[OptimalString], L_SHIPMODE: Rep[OptimalString], L_COMMENT: Rep[OptimalString]): Rep[LINEITEMRecord] = LINEITEMRecordNew(L_ORDERKEY, L_PARTKEY, L_SUPPKEY, L_LINENUMBER, L_QUANTITY, L_EXTENDEDPRICE, L_DISCOUNT, L_TAX, L_RETURNFLAG, L_LINESTATUS, L_SHIPDATE, L_COMMITDATE, L_RECEIPTDATE, L_SHIPINSTRUCT, L_SHIPMODE, L_COMMENT)
  def lINEITEMRecordGetField(self: Rep[LINEITEMRecord], key: Rep[String]): Rep[Option[Any]] = LINEITEMRecordGetField(self, key)
  def lINEITEMRecord_Field_L_COMMENT(self: Rep[LINEITEMRecord]): Rep[OptimalString] = LINEITEMRecord_Field_L_COMMENT(self)
  def lINEITEMRecord_Field_L_SHIPMODE(self: Rep[LINEITEMRecord]): Rep[OptimalString] = LINEITEMRecord_Field_L_SHIPMODE(self)
  def lINEITEMRecord_Field_L_SHIPINSTRUCT(self: Rep[LINEITEMRecord]): Rep[OptimalString] = LINEITEMRecord_Field_L_SHIPINSTRUCT(self)
  def lINEITEMRecord_Field_L_RECEIPTDATE(self: Rep[LINEITEMRecord]): Rep[Long] = LINEITEMRecord_Field_L_RECEIPTDATE(self)
  def lINEITEMRecord_Field_L_COMMITDATE(self: Rep[LINEITEMRecord]): Rep[Long] = LINEITEMRecord_Field_L_COMMITDATE(self)
  def lINEITEMRecord_Field_L_SHIPDATE(self: Rep[LINEITEMRecord]): Rep[Long] = LINEITEMRecord_Field_L_SHIPDATE(self)
  def lINEITEMRecord_Field_L_LINESTATUS(self: Rep[LINEITEMRecord]): Rep[Character] = LINEITEMRecord_Field_L_LINESTATUS(self)
  def lINEITEMRecord_Field_L_RETURNFLAG(self: Rep[LINEITEMRecord]): Rep[Character] = LINEITEMRecord_Field_L_RETURNFLAG(self)
  def lINEITEMRecord_Field_L_TAX(self: Rep[LINEITEMRecord]): Rep[Double] = LINEITEMRecord_Field_L_TAX(self)
  def lINEITEMRecord_Field_L_DISCOUNT(self: Rep[LINEITEMRecord]): Rep[Double] = LINEITEMRecord_Field_L_DISCOUNT(self)
  def lINEITEMRecord_Field_L_EXTENDEDPRICE(self: Rep[LINEITEMRecord]): Rep[Double] = LINEITEMRecord_Field_L_EXTENDEDPRICE(self)
  def lINEITEMRecord_Field_L_QUANTITY(self: Rep[LINEITEMRecord]): Rep[Double] = LINEITEMRecord_Field_L_QUANTITY(self)
  def lINEITEMRecord_Field_L_LINENUMBER(self: Rep[LINEITEMRecord]): Rep[Int] = LINEITEMRecord_Field_L_LINENUMBER(self)
  def lINEITEMRecord_Field_L_SUPPKEY(self: Rep[LINEITEMRecord]): Rep[Int] = LINEITEMRecord_Field_L_SUPPKEY(self)
  def lINEITEMRecord_Field_L_PARTKEY(self: Rep[LINEITEMRecord]): Rep[Int] = LINEITEMRecord_Field_L_PARTKEY(self)
  def lINEITEMRecord_Field_L_ORDERKEY(self: Rep[LINEITEMRecord]): Rep[Int] = LINEITEMRecord_Field_L_ORDERKEY(self)
  type LINEITEMRecord = ch.epfl.data.legobase.queryengine.TPCHRelations.LINEITEMRecord
  case object LINEITEMRecordType extends TypeRep[LINEITEMRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = LINEITEMRecordType
    val name = "LINEITEMRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[LINEITEMRecord]
  }
  implicit val typeLINEITEMRecord = LINEITEMRecordType
}
trait LINEITEMRecordImplicits { this: LINEITEMRecordComponent =>
  // Add implicit conversions here!
}
trait LINEITEMRecordImplementations { self: DeepDSL =>

}
trait LINEITEMRecordComponent extends LINEITEMRecordOps with LINEITEMRecordImplicits { self: DeepDSL => }

trait SUPPLIERRecordOps extends Base { this: DeepDSL =>
  implicit class SUPPLIERRecordRep(self: Rep[SUPPLIERRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = sUPPLIERRecordGetField(self, key)
    def S_COMMENT: Rep[OptimalString] = sUPPLIERRecord_Field_S_COMMENT(self)
    def S_ACCTBAL: Rep[Double] = sUPPLIERRecord_Field_S_ACCTBAL(self)
    def S_PHONE: Rep[OptimalString] = sUPPLIERRecord_Field_S_PHONE(self)
    def S_NATIONKEY: Rep[Int] = sUPPLIERRecord_Field_S_NATIONKEY(self)
    def S_ADDRESS: Rep[OptimalString] = sUPPLIERRecord_Field_S_ADDRESS(self)
    def S_NAME: Rep[OptimalString] = sUPPLIERRecord_Field_S_NAME(self)
    def S_SUPPKEY: Rep[Int] = sUPPLIERRecord_Field_S_SUPPKEY(self)
  }
  object SUPPLIERRecord {

  }
  // constructors
  def __newSUPPLIERRecord(S_SUPPKEY: Rep[Int], S_NAME: Rep[OptimalString], S_ADDRESS: Rep[OptimalString], S_NATIONKEY: Rep[Int], S_PHONE: Rep[OptimalString], S_ACCTBAL: Rep[Double], S_COMMENT: Rep[OptimalString]): Rep[SUPPLIERRecord] = sUPPLIERRecordNew(S_SUPPKEY, S_NAME, S_ADDRESS, S_NATIONKEY, S_PHONE, S_ACCTBAL, S_COMMENT)
  // case classes
  case class SUPPLIERRecordNew(S_SUPPKEY: Rep[Int], S_NAME: Rep[OptimalString], S_ADDRESS: Rep[OptimalString], S_NATIONKEY: Rep[Int], S_PHONE: Rep[OptimalString], S_ACCTBAL: Rep[Double], S_COMMENT: Rep[OptimalString]) extends ConstructorDef[SUPPLIERRecord](List(), "SUPPLIERRecord", List(List(S_SUPPKEY, S_NAME, S_ADDRESS, S_NATIONKEY, S_PHONE, S_ACCTBAL, S_COMMENT))) {
    override def curriedConstructor = (copy _).curried
  }

  case class SUPPLIERRecordGetField(self: Rep[SUPPLIERRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class SUPPLIERRecord_Field_S_COMMENT(self: Rep[SUPPLIERRecord]) extends FieldDef[OptimalString](self, "S_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class SUPPLIERRecord_Field_S_ACCTBAL(self: Rep[SUPPLIERRecord]) extends FieldDef[Double](self, "S_ACCTBAL") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class SUPPLIERRecord_Field_S_PHONE(self: Rep[SUPPLIERRecord]) extends FieldDef[OptimalString](self, "S_PHONE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class SUPPLIERRecord_Field_S_NATIONKEY(self: Rep[SUPPLIERRecord]) extends FieldDef[Int](self, "S_NATIONKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class SUPPLIERRecord_Field_S_ADDRESS(self: Rep[SUPPLIERRecord]) extends FieldDef[OptimalString](self, "S_ADDRESS") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class SUPPLIERRecord_Field_S_NAME(self: Rep[SUPPLIERRecord]) extends FieldDef[OptimalString](self, "S_NAME") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class SUPPLIERRecord_Field_S_SUPPKEY(self: Rep[SUPPLIERRecord]) extends FieldDef[Int](self, "S_SUPPKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def sUPPLIERRecordNew(S_SUPPKEY: Rep[Int], S_NAME: Rep[OptimalString], S_ADDRESS: Rep[OptimalString], S_NATIONKEY: Rep[Int], S_PHONE: Rep[OptimalString], S_ACCTBAL: Rep[Double], S_COMMENT: Rep[OptimalString]): Rep[SUPPLIERRecord] = SUPPLIERRecordNew(S_SUPPKEY, S_NAME, S_ADDRESS, S_NATIONKEY, S_PHONE, S_ACCTBAL, S_COMMENT)
  def sUPPLIERRecordGetField(self: Rep[SUPPLIERRecord], key: Rep[String]): Rep[Option[Any]] = SUPPLIERRecordGetField(self, key)
  def sUPPLIERRecord_Field_S_COMMENT(self: Rep[SUPPLIERRecord]): Rep[OptimalString] = SUPPLIERRecord_Field_S_COMMENT(self)
  def sUPPLIERRecord_Field_S_ACCTBAL(self: Rep[SUPPLIERRecord]): Rep[Double] = SUPPLIERRecord_Field_S_ACCTBAL(self)
  def sUPPLIERRecord_Field_S_PHONE(self: Rep[SUPPLIERRecord]): Rep[OptimalString] = SUPPLIERRecord_Field_S_PHONE(self)
  def sUPPLIERRecord_Field_S_NATIONKEY(self: Rep[SUPPLIERRecord]): Rep[Int] = SUPPLIERRecord_Field_S_NATIONKEY(self)
  def sUPPLIERRecord_Field_S_ADDRESS(self: Rep[SUPPLIERRecord]): Rep[OptimalString] = SUPPLIERRecord_Field_S_ADDRESS(self)
  def sUPPLIERRecord_Field_S_NAME(self: Rep[SUPPLIERRecord]): Rep[OptimalString] = SUPPLIERRecord_Field_S_NAME(self)
  def sUPPLIERRecord_Field_S_SUPPKEY(self: Rep[SUPPLIERRecord]): Rep[Int] = SUPPLIERRecord_Field_S_SUPPKEY(self)
  type SUPPLIERRecord = ch.epfl.data.legobase.queryengine.TPCHRelations.SUPPLIERRecord
  case object SUPPLIERRecordType extends TypeRep[SUPPLIERRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = SUPPLIERRecordType
    val name = "SUPPLIERRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[SUPPLIERRecord]
  }
  implicit val typeSUPPLIERRecord = SUPPLIERRecordType
}
trait SUPPLIERRecordImplicits { this: SUPPLIERRecordComponent =>
  // Add implicit conversions here!
}
trait SUPPLIERRecordImplementations { self: DeepDSL =>

}
trait SUPPLIERRecordComponent extends SUPPLIERRecordOps with SUPPLIERRecordImplicits { self: DeepDSL => }

trait PARTSUPPRecordOps extends Base { this: DeepDSL =>
  implicit class PARTSUPPRecordRep(self: Rep[PARTSUPPRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = pARTSUPPRecordGetField(self, key)
    def PS_COMMENT: Rep[OptimalString] = pARTSUPPRecord_Field_PS_COMMENT(self)
    def PS_SUPPLYCOST: Rep[Double] = pARTSUPPRecord_Field_PS_SUPPLYCOST(self)
    def PS_AVAILQTY: Rep[Int] = pARTSUPPRecord_Field_PS_AVAILQTY(self)
    def PS_SUPPKEY: Rep[Int] = pARTSUPPRecord_Field_PS_SUPPKEY(self)
    def PS_PARTKEY: Rep[Int] = pARTSUPPRecord_Field_PS_PARTKEY(self)
  }
  object PARTSUPPRecord {

  }
  // constructors
  def __newPARTSUPPRecord(PS_PARTKEY: Rep[Int], PS_SUPPKEY: Rep[Int], PS_AVAILQTY: Rep[Int], PS_SUPPLYCOST: Rep[Double], PS_COMMENT: Rep[OptimalString]): Rep[PARTSUPPRecord] = pARTSUPPRecordNew(PS_PARTKEY, PS_SUPPKEY, PS_AVAILQTY, PS_SUPPLYCOST, PS_COMMENT)
  // case classes
  case class PARTSUPPRecordNew(PS_PARTKEY: Rep[Int], PS_SUPPKEY: Rep[Int], PS_AVAILQTY: Rep[Int], PS_SUPPLYCOST: Rep[Double], PS_COMMENT: Rep[OptimalString]) extends ConstructorDef[PARTSUPPRecord](List(), "PARTSUPPRecord", List(List(PS_PARTKEY, PS_SUPPKEY, PS_AVAILQTY, PS_SUPPLYCOST, PS_COMMENT))) {
    override def curriedConstructor = (copy _).curried
  }

  case class PARTSUPPRecordGetField(self: Rep[PARTSUPPRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class PARTSUPPRecord_Field_PS_COMMENT(self: Rep[PARTSUPPRecord]) extends FieldDef[OptimalString](self, "PS_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTSUPPRecord_Field_PS_SUPPLYCOST(self: Rep[PARTSUPPRecord]) extends FieldDef[Double](self, "PS_SUPPLYCOST") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTSUPPRecord_Field_PS_AVAILQTY(self: Rep[PARTSUPPRecord]) extends FieldDef[Int](self, "PS_AVAILQTY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTSUPPRecord_Field_PS_SUPPKEY(self: Rep[PARTSUPPRecord]) extends FieldDef[Int](self, "PS_SUPPKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTSUPPRecord_Field_PS_PARTKEY(self: Rep[PARTSUPPRecord]) extends FieldDef[Int](self, "PS_PARTKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def pARTSUPPRecordNew(PS_PARTKEY: Rep[Int], PS_SUPPKEY: Rep[Int], PS_AVAILQTY: Rep[Int], PS_SUPPLYCOST: Rep[Double], PS_COMMENT: Rep[OptimalString]): Rep[PARTSUPPRecord] = PARTSUPPRecordNew(PS_PARTKEY, PS_SUPPKEY, PS_AVAILQTY, PS_SUPPLYCOST, PS_COMMENT)
  def pARTSUPPRecordGetField(self: Rep[PARTSUPPRecord], key: Rep[String]): Rep[Option[Any]] = PARTSUPPRecordGetField(self, key)
  def pARTSUPPRecord_Field_PS_COMMENT(self: Rep[PARTSUPPRecord]): Rep[OptimalString] = PARTSUPPRecord_Field_PS_COMMENT(self)
  def pARTSUPPRecord_Field_PS_SUPPLYCOST(self: Rep[PARTSUPPRecord]): Rep[Double] = PARTSUPPRecord_Field_PS_SUPPLYCOST(self)
  def pARTSUPPRecord_Field_PS_AVAILQTY(self: Rep[PARTSUPPRecord]): Rep[Int] = PARTSUPPRecord_Field_PS_AVAILQTY(self)
  def pARTSUPPRecord_Field_PS_SUPPKEY(self: Rep[PARTSUPPRecord]): Rep[Int] = PARTSUPPRecord_Field_PS_SUPPKEY(self)
  def pARTSUPPRecord_Field_PS_PARTKEY(self: Rep[PARTSUPPRecord]): Rep[Int] = PARTSUPPRecord_Field_PS_PARTKEY(self)
  type PARTSUPPRecord = ch.epfl.data.legobase.queryengine.TPCHRelations.PARTSUPPRecord
  case object PARTSUPPRecordType extends TypeRep[PARTSUPPRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = PARTSUPPRecordType
    val name = "PARTSUPPRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[PARTSUPPRecord]
  }
  implicit val typePARTSUPPRecord = PARTSUPPRecordType
}
trait PARTSUPPRecordImplicits { this: PARTSUPPRecordComponent =>
  // Add implicit conversions here!
}
trait PARTSUPPRecordImplementations { self: DeepDSL =>

}
trait PARTSUPPRecordComponent extends PARTSUPPRecordOps with PARTSUPPRecordImplicits { self: DeepDSL => }

trait REGIONRecordOps extends Base { this: DeepDSL =>
  implicit class REGIONRecordRep(self: Rep[REGIONRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = rEGIONRecordGetField(self, key)
    def R_COMMENT: Rep[OptimalString] = rEGIONRecord_Field_R_COMMENT(self)
    def R_NAME: Rep[OptimalString] = rEGIONRecord_Field_R_NAME(self)
    def R_REGIONKEY: Rep[Int] = rEGIONRecord_Field_R_REGIONKEY(self)
  }
  object REGIONRecord {

  }
  // constructors
  def __newREGIONRecord(R_REGIONKEY: Rep[Int], R_NAME: Rep[OptimalString], R_COMMENT: Rep[OptimalString]): Rep[REGIONRecord] = rEGIONRecordNew(R_REGIONKEY, R_NAME, R_COMMENT)
  // case classes
  case class REGIONRecordNew(R_REGIONKEY: Rep[Int], R_NAME: Rep[OptimalString], R_COMMENT: Rep[OptimalString]) extends ConstructorDef[REGIONRecord](List(), "REGIONRecord", List(List(R_REGIONKEY, R_NAME, R_COMMENT))) {
    override def curriedConstructor = (copy _).curried
  }

  case class REGIONRecordGetField(self: Rep[REGIONRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class REGIONRecord_Field_R_COMMENT(self: Rep[REGIONRecord]) extends FieldDef[OptimalString](self, "R_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class REGIONRecord_Field_R_NAME(self: Rep[REGIONRecord]) extends FieldDef[OptimalString](self, "R_NAME") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class REGIONRecord_Field_R_REGIONKEY(self: Rep[REGIONRecord]) extends FieldDef[Int](self, "R_REGIONKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def rEGIONRecordNew(R_REGIONKEY: Rep[Int], R_NAME: Rep[OptimalString], R_COMMENT: Rep[OptimalString]): Rep[REGIONRecord] = REGIONRecordNew(R_REGIONKEY, R_NAME, R_COMMENT)
  def rEGIONRecordGetField(self: Rep[REGIONRecord], key: Rep[String]): Rep[Option[Any]] = REGIONRecordGetField(self, key)
  def rEGIONRecord_Field_R_COMMENT(self: Rep[REGIONRecord]): Rep[OptimalString] = REGIONRecord_Field_R_COMMENT(self)
  def rEGIONRecord_Field_R_NAME(self: Rep[REGIONRecord]): Rep[OptimalString] = REGIONRecord_Field_R_NAME(self)
  def rEGIONRecord_Field_R_REGIONKEY(self: Rep[REGIONRecord]): Rep[Int] = REGIONRecord_Field_R_REGIONKEY(self)
  type REGIONRecord = ch.epfl.data.legobase.queryengine.TPCHRelations.REGIONRecord
  case object REGIONRecordType extends TypeRep[REGIONRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = REGIONRecordType
    val name = "REGIONRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[REGIONRecord]
  }
  implicit val typeREGIONRecord = REGIONRecordType
}
trait REGIONRecordImplicits { this: REGIONRecordComponent =>
  // Add implicit conversions here!
}
trait REGIONRecordImplementations { self: DeepDSL =>

}
trait REGIONRecordComponent extends REGIONRecordOps with REGIONRecordImplicits { self: DeepDSL => }

trait NATIONRecordOps extends Base { this: DeepDSL =>
  implicit class NATIONRecordRep(self: Rep[NATIONRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = nATIONRecordGetField(self, key)
    def N_COMMENT: Rep[OptimalString] = nATIONRecord_Field_N_COMMENT(self)
    def N_REGIONKEY: Rep[Int] = nATIONRecord_Field_N_REGIONKEY(self)
    def N_NAME: Rep[OptimalString] = nATIONRecord_Field_N_NAME(self)
    def N_NATIONKEY: Rep[Int] = nATIONRecord_Field_N_NATIONKEY(self)
  }
  object NATIONRecord {

  }
  // constructors
  def __newNATIONRecord(N_NATIONKEY: Rep[Int], N_NAME: Rep[OptimalString], N_REGIONKEY: Rep[Int], N_COMMENT: Rep[OptimalString]): Rep[NATIONRecord] = nATIONRecordNew(N_NATIONKEY, N_NAME, N_REGIONKEY, N_COMMENT)
  // case classes
  case class NATIONRecordNew(N_NATIONKEY: Rep[Int], N_NAME: Rep[OptimalString], N_REGIONKEY: Rep[Int], N_COMMENT: Rep[OptimalString]) extends ConstructorDef[NATIONRecord](List(), "NATIONRecord", List(List(N_NATIONKEY, N_NAME, N_REGIONKEY, N_COMMENT))) {
    override def curriedConstructor = (copy _).curried
  }

  case class NATIONRecordGetField(self: Rep[NATIONRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class NATIONRecord_Field_N_COMMENT(self: Rep[NATIONRecord]) extends FieldDef[OptimalString](self, "N_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class NATIONRecord_Field_N_REGIONKEY(self: Rep[NATIONRecord]) extends FieldDef[Int](self, "N_REGIONKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class NATIONRecord_Field_N_NAME(self: Rep[NATIONRecord]) extends FieldDef[OptimalString](self, "N_NAME") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class NATIONRecord_Field_N_NATIONKEY(self: Rep[NATIONRecord]) extends FieldDef[Int](self, "N_NATIONKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def nATIONRecordNew(N_NATIONKEY: Rep[Int], N_NAME: Rep[OptimalString], N_REGIONKEY: Rep[Int], N_COMMENT: Rep[OptimalString]): Rep[NATIONRecord] = NATIONRecordNew(N_NATIONKEY, N_NAME, N_REGIONKEY, N_COMMENT)
  def nATIONRecordGetField(self: Rep[NATIONRecord], key: Rep[String]): Rep[Option[Any]] = NATIONRecordGetField(self, key)
  def nATIONRecord_Field_N_COMMENT(self: Rep[NATIONRecord]): Rep[OptimalString] = NATIONRecord_Field_N_COMMENT(self)
  def nATIONRecord_Field_N_REGIONKEY(self: Rep[NATIONRecord]): Rep[Int] = NATIONRecord_Field_N_REGIONKEY(self)
  def nATIONRecord_Field_N_NAME(self: Rep[NATIONRecord]): Rep[OptimalString] = NATIONRecord_Field_N_NAME(self)
  def nATIONRecord_Field_N_NATIONKEY(self: Rep[NATIONRecord]): Rep[Int] = NATIONRecord_Field_N_NATIONKEY(self)
  type NATIONRecord = ch.epfl.data.legobase.queryengine.TPCHRelations.NATIONRecord
  case object NATIONRecordType extends TypeRep[NATIONRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = NATIONRecordType
    val name = "NATIONRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[NATIONRecord]
  }
  implicit val typeNATIONRecord = NATIONRecordType
}
trait NATIONRecordImplicits { this: NATIONRecordComponent =>
  // Add implicit conversions here!
}
trait NATIONRecordImplementations { self: DeepDSL =>

}
trait NATIONRecordComponent extends NATIONRecordOps with NATIONRecordImplicits { self: DeepDSL => }

trait PARTRecordOps extends Base { this: DeepDSL =>
  implicit class PARTRecordRep(self: Rep[PARTRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = pARTRecordGetField(self, key)
    def P_COMMENT: Rep[OptimalString] = pARTRecord_Field_P_COMMENT(self)
    def P_RETAILPRICE: Rep[Double] = pARTRecord_Field_P_RETAILPRICE(self)
    def P_CONTAINER: Rep[OptimalString] = pARTRecord_Field_P_CONTAINER(self)
    def P_SIZE: Rep[Int] = pARTRecord_Field_P_SIZE(self)
    def P_TYPE: Rep[OptimalString] = pARTRecord_Field_P_TYPE(self)
    def P_BRAND: Rep[OptimalString] = pARTRecord_Field_P_BRAND(self)
    def P_MFGR: Rep[OptimalString] = pARTRecord_Field_P_MFGR(self)
    def P_NAME: Rep[OptimalString] = pARTRecord_Field_P_NAME(self)
    def P_PARTKEY: Rep[Int] = pARTRecord_Field_P_PARTKEY(self)
  }
  object PARTRecord {

  }
  // constructors
  def __newPARTRecord(P_PARTKEY: Rep[Int], P_NAME: Rep[OptimalString], P_MFGR: Rep[OptimalString], P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int], P_CONTAINER: Rep[OptimalString], P_RETAILPRICE: Rep[Double], P_COMMENT: Rep[OptimalString]): Rep[PARTRecord] = pARTRecordNew(P_PARTKEY, P_NAME, P_MFGR, P_BRAND, P_TYPE, P_SIZE, P_CONTAINER, P_RETAILPRICE, P_COMMENT)
  // case classes
  case class PARTRecordNew(P_PARTKEY: Rep[Int], P_NAME: Rep[OptimalString], P_MFGR: Rep[OptimalString], P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int], P_CONTAINER: Rep[OptimalString], P_RETAILPRICE: Rep[Double], P_COMMENT: Rep[OptimalString]) extends ConstructorDef[PARTRecord](List(), "PARTRecord", List(List(P_PARTKEY, P_NAME, P_MFGR, P_BRAND, P_TYPE, P_SIZE, P_CONTAINER, P_RETAILPRICE, P_COMMENT))) {
    override def curriedConstructor = (copy _).curried
  }

  case class PARTRecordGetField(self: Rep[PARTRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class PARTRecord_Field_P_COMMENT(self: Rep[PARTRecord]) extends FieldDef[OptimalString](self, "P_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTRecord_Field_P_RETAILPRICE(self: Rep[PARTRecord]) extends FieldDef[Double](self, "P_RETAILPRICE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTRecord_Field_P_CONTAINER(self: Rep[PARTRecord]) extends FieldDef[OptimalString](self, "P_CONTAINER") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTRecord_Field_P_SIZE(self: Rep[PARTRecord]) extends FieldDef[Int](self, "P_SIZE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTRecord_Field_P_TYPE(self: Rep[PARTRecord]) extends FieldDef[OptimalString](self, "P_TYPE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTRecord_Field_P_BRAND(self: Rep[PARTRecord]) extends FieldDef[OptimalString](self, "P_BRAND") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTRecord_Field_P_MFGR(self: Rep[PARTRecord]) extends FieldDef[OptimalString](self, "P_MFGR") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTRecord_Field_P_NAME(self: Rep[PARTRecord]) extends FieldDef[OptimalString](self, "P_NAME") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class PARTRecord_Field_P_PARTKEY(self: Rep[PARTRecord]) extends FieldDef[Int](self, "P_PARTKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def pARTRecordNew(P_PARTKEY: Rep[Int], P_NAME: Rep[OptimalString], P_MFGR: Rep[OptimalString], P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int], P_CONTAINER: Rep[OptimalString], P_RETAILPRICE: Rep[Double], P_COMMENT: Rep[OptimalString]): Rep[PARTRecord] = PARTRecordNew(P_PARTKEY, P_NAME, P_MFGR, P_BRAND, P_TYPE, P_SIZE, P_CONTAINER, P_RETAILPRICE, P_COMMENT)
  def pARTRecordGetField(self: Rep[PARTRecord], key: Rep[String]): Rep[Option[Any]] = PARTRecordGetField(self, key)
  def pARTRecord_Field_P_COMMENT(self: Rep[PARTRecord]): Rep[OptimalString] = PARTRecord_Field_P_COMMENT(self)
  def pARTRecord_Field_P_RETAILPRICE(self: Rep[PARTRecord]): Rep[Double] = PARTRecord_Field_P_RETAILPRICE(self)
  def pARTRecord_Field_P_CONTAINER(self: Rep[PARTRecord]): Rep[OptimalString] = PARTRecord_Field_P_CONTAINER(self)
  def pARTRecord_Field_P_SIZE(self: Rep[PARTRecord]): Rep[Int] = PARTRecord_Field_P_SIZE(self)
  def pARTRecord_Field_P_TYPE(self: Rep[PARTRecord]): Rep[OptimalString] = PARTRecord_Field_P_TYPE(self)
  def pARTRecord_Field_P_BRAND(self: Rep[PARTRecord]): Rep[OptimalString] = PARTRecord_Field_P_BRAND(self)
  def pARTRecord_Field_P_MFGR(self: Rep[PARTRecord]): Rep[OptimalString] = PARTRecord_Field_P_MFGR(self)
  def pARTRecord_Field_P_NAME(self: Rep[PARTRecord]): Rep[OptimalString] = PARTRecord_Field_P_NAME(self)
  def pARTRecord_Field_P_PARTKEY(self: Rep[PARTRecord]): Rep[Int] = PARTRecord_Field_P_PARTKEY(self)
  type PARTRecord = ch.epfl.data.legobase.queryengine.TPCHRelations.PARTRecord
  case object PARTRecordType extends TypeRep[PARTRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = PARTRecordType
    val name = "PARTRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[PARTRecord]
  }
  implicit val typePARTRecord = PARTRecordType
}
trait PARTRecordImplicits { this: PARTRecordComponent =>
  // Add implicit conversions here!
}
trait PARTRecordImplementations { self: DeepDSL =>

}
trait PARTRecordComponent extends PARTRecordOps with PARTRecordImplicits { self: DeepDSL => }

trait CUSTOMERRecordOps extends Base { this: DeepDSL =>
  implicit class CUSTOMERRecordRep(self: Rep[CUSTOMERRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = cUSTOMERRecordGetField(self, key)
    def C_COMMENT: Rep[OptimalString] = cUSTOMERRecord_Field_C_COMMENT(self)
    def C_MKTSEGMENT: Rep[OptimalString] = cUSTOMERRecord_Field_C_MKTSEGMENT(self)
    def C_ACCTBAL: Rep[Double] = cUSTOMERRecord_Field_C_ACCTBAL(self)
    def C_PHONE: Rep[OptimalString] = cUSTOMERRecord_Field_C_PHONE(self)
    def C_NATIONKEY: Rep[Int] = cUSTOMERRecord_Field_C_NATIONKEY(self)
    def C_ADDRESS: Rep[OptimalString] = cUSTOMERRecord_Field_C_ADDRESS(self)
    def C_NAME: Rep[OptimalString] = cUSTOMERRecord_Field_C_NAME(self)
    def C_CUSTKEY: Rep[Int] = cUSTOMERRecord_Field_C_CUSTKEY(self)
  }
  object CUSTOMERRecord {

  }
  // constructors
  def __newCUSTOMERRecord(C_CUSTKEY: Rep[Int], C_NAME: Rep[OptimalString], C_ADDRESS: Rep[OptimalString], C_NATIONKEY: Rep[Int], C_PHONE: Rep[OptimalString], C_ACCTBAL: Rep[Double], C_MKTSEGMENT: Rep[OptimalString], C_COMMENT: Rep[OptimalString]): Rep[CUSTOMERRecord] = cUSTOMERRecordNew(C_CUSTKEY, C_NAME, C_ADDRESS, C_NATIONKEY, C_PHONE, C_ACCTBAL, C_MKTSEGMENT, C_COMMENT)
  // case classes
  case class CUSTOMERRecordNew(C_CUSTKEY: Rep[Int], C_NAME: Rep[OptimalString], C_ADDRESS: Rep[OptimalString], C_NATIONKEY: Rep[Int], C_PHONE: Rep[OptimalString], C_ACCTBAL: Rep[Double], C_MKTSEGMENT: Rep[OptimalString], C_COMMENT: Rep[OptimalString]) extends ConstructorDef[CUSTOMERRecord](List(), "CUSTOMERRecord", List(List(C_CUSTKEY, C_NAME, C_ADDRESS, C_NATIONKEY, C_PHONE, C_ACCTBAL, C_MKTSEGMENT, C_COMMENT))) {
    override def curriedConstructor = (copy _).curried
  }

  case class CUSTOMERRecordGetField(self: Rep[CUSTOMERRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class CUSTOMERRecord_Field_C_COMMENT(self: Rep[CUSTOMERRecord]) extends FieldDef[OptimalString](self, "C_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class CUSTOMERRecord_Field_C_MKTSEGMENT(self: Rep[CUSTOMERRecord]) extends FieldDef[OptimalString](self, "C_MKTSEGMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class CUSTOMERRecord_Field_C_ACCTBAL(self: Rep[CUSTOMERRecord]) extends FieldDef[Double](self, "C_ACCTBAL") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class CUSTOMERRecord_Field_C_PHONE(self: Rep[CUSTOMERRecord]) extends FieldDef[OptimalString](self, "C_PHONE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class CUSTOMERRecord_Field_C_NATIONKEY(self: Rep[CUSTOMERRecord]) extends FieldDef[Int](self, "C_NATIONKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class CUSTOMERRecord_Field_C_ADDRESS(self: Rep[CUSTOMERRecord]) extends FieldDef[OptimalString](self, "C_ADDRESS") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class CUSTOMERRecord_Field_C_NAME(self: Rep[CUSTOMERRecord]) extends FieldDef[OptimalString](self, "C_NAME") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class CUSTOMERRecord_Field_C_CUSTKEY(self: Rep[CUSTOMERRecord]) extends FieldDef[Int](self, "C_CUSTKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def cUSTOMERRecordNew(C_CUSTKEY: Rep[Int], C_NAME: Rep[OptimalString], C_ADDRESS: Rep[OptimalString], C_NATIONKEY: Rep[Int], C_PHONE: Rep[OptimalString], C_ACCTBAL: Rep[Double], C_MKTSEGMENT: Rep[OptimalString], C_COMMENT: Rep[OptimalString]): Rep[CUSTOMERRecord] = CUSTOMERRecordNew(C_CUSTKEY, C_NAME, C_ADDRESS, C_NATIONKEY, C_PHONE, C_ACCTBAL, C_MKTSEGMENT, C_COMMENT)
  def cUSTOMERRecordGetField(self: Rep[CUSTOMERRecord], key: Rep[String]): Rep[Option[Any]] = CUSTOMERRecordGetField(self, key)
  def cUSTOMERRecord_Field_C_COMMENT(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = CUSTOMERRecord_Field_C_COMMENT(self)
  def cUSTOMERRecord_Field_C_MKTSEGMENT(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = CUSTOMERRecord_Field_C_MKTSEGMENT(self)
  def cUSTOMERRecord_Field_C_ACCTBAL(self: Rep[CUSTOMERRecord]): Rep[Double] = CUSTOMERRecord_Field_C_ACCTBAL(self)
  def cUSTOMERRecord_Field_C_PHONE(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = CUSTOMERRecord_Field_C_PHONE(self)
  def cUSTOMERRecord_Field_C_NATIONKEY(self: Rep[CUSTOMERRecord]): Rep[Int] = CUSTOMERRecord_Field_C_NATIONKEY(self)
  def cUSTOMERRecord_Field_C_ADDRESS(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = CUSTOMERRecord_Field_C_ADDRESS(self)
  def cUSTOMERRecord_Field_C_NAME(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = CUSTOMERRecord_Field_C_NAME(self)
  def cUSTOMERRecord_Field_C_CUSTKEY(self: Rep[CUSTOMERRecord]): Rep[Int] = CUSTOMERRecord_Field_C_CUSTKEY(self)
  type CUSTOMERRecord = ch.epfl.data.legobase.queryengine.TPCHRelations.CUSTOMERRecord
  case object CUSTOMERRecordType extends TypeRep[CUSTOMERRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = CUSTOMERRecordType
    val name = "CUSTOMERRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[CUSTOMERRecord]
  }
  implicit val typeCUSTOMERRecord = CUSTOMERRecordType
}
trait CUSTOMERRecordImplicits { this: CUSTOMERRecordComponent =>
  // Add implicit conversions here!
}
trait CUSTOMERRecordImplementations { self: DeepDSL =>

}
trait CUSTOMERRecordComponent extends CUSTOMERRecordOps with CUSTOMERRecordImplicits { self: DeepDSL => }

trait ORDERSRecordOps extends Base { this: DeepDSL =>
  implicit class ORDERSRecordRep(self: Rep[ORDERSRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = oRDERSRecordGetField(self, key)
    def O_COMMENT: Rep[OptimalString] = oRDERSRecord_Field_O_COMMENT(self)
    def O_SHIPPRIORITY: Rep[Int] = oRDERSRecord_Field_O_SHIPPRIORITY(self)
    def O_CLERK: Rep[OptimalString] = oRDERSRecord_Field_O_CLERK(self)
    def O_ORDERPRIORITY: Rep[OptimalString] = oRDERSRecord_Field_O_ORDERPRIORITY(self)
    def O_ORDERDATE: Rep[Long] = oRDERSRecord_Field_O_ORDERDATE(self)
    def O_TOTALPRICE: Rep[Double] = oRDERSRecord_Field_O_TOTALPRICE(self)
    def O_ORDERSTATUS: Rep[Character] = oRDERSRecord_Field_O_ORDERSTATUS(self)
    def O_CUSTKEY: Rep[Int] = oRDERSRecord_Field_O_CUSTKEY(self)
    def O_ORDERKEY: Rep[Int] = oRDERSRecord_Field_O_ORDERKEY(self)
  }
  object ORDERSRecord {

  }
  // constructors
  def __newORDERSRecord(O_ORDERKEY: Rep[Int], O_CUSTKEY: Rep[Int], O_ORDERSTATUS: Rep[Character], O_TOTALPRICE: Rep[Double], O_ORDERDATE: Rep[Long], O_ORDERPRIORITY: Rep[OptimalString], O_CLERK: Rep[OptimalString], O_SHIPPRIORITY: Rep[Int], O_COMMENT: Rep[OptimalString]): Rep[ORDERSRecord] = oRDERSRecordNew(O_ORDERKEY, O_CUSTKEY, O_ORDERSTATUS, O_TOTALPRICE, O_ORDERDATE, O_ORDERPRIORITY, O_CLERK, O_SHIPPRIORITY, O_COMMENT)
  // case classes
  case class ORDERSRecordNew(O_ORDERKEY: Rep[Int], O_CUSTKEY: Rep[Int], O_ORDERSTATUS: Rep[Character], O_TOTALPRICE: Rep[Double], O_ORDERDATE: Rep[Long], O_ORDERPRIORITY: Rep[OptimalString], O_CLERK: Rep[OptimalString], O_SHIPPRIORITY: Rep[Int], O_COMMENT: Rep[OptimalString]) extends ConstructorDef[ORDERSRecord](List(), "ORDERSRecord", List(List(O_ORDERKEY, O_CUSTKEY, O_ORDERSTATUS, O_TOTALPRICE, O_ORDERDATE, O_ORDERPRIORITY, O_CLERK, O_SHIPPRIORITY, O_COMMENT))) {
    override def curriedConstructor = (copy _).curried
  }

  case class ORDERSRecordGetField(self: Rep[ORDERSRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class ORDERSRecord_Field_O_COMMENT(self: Rep[ORDERSRecord]) extends FieldDef[OptimalString](self, "O_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class ORDERSRecord_Field_O_SHIPPRIORITY(self: Rep[ORDERSRecord]) extends FieldDef[Int](self, "O_SHIPPRIORITY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class ORDERSRecord_Field_O_CLERK(self: Rep[ORDERSRecord]) extends FieldDef[OptimalString](self, "O_CLERK") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class ORDERSRecord_Field_O_ORDERPRIORITY(self: Rep[ORDERSRecord]) extends FieldDef[OptimalString](self, "O_ORDERPRIORITY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class ORDERSRecord_Field_O_ORDERDATE(self: Rep[ORDERSRecord]) extends FieldDef[Long](self, "O_ORDERDATE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class ORDERSRecord_Field_O_TOTALPRICE(self: Rep[ORDERSRecord]) extends FieldDef[Double](self, "O_TOTALPRICE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class ORDERSRecord_Field_O_ORDERSTATUS(self: Rep[ORDERSRecord]) extends FieldDef[Character](self, "O_ORDERSTATUS") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class ORDERSRecord_Field_O_CUSTKEY(self: Rep[ORDERSRecord]) extends FieldDef[Int](self, "O_CUSTKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class ORDERSRecord_Field_O_ORDERKEY(self: Rep[ORDERSRecord]) extends FieldDef[Int](self, "O_ORDERKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def oRDERSRecordNew(O_ORDERKEY: Rep[Int], O_CUSTKEY: Rep[Int], O_ORDERSTATUS: Rep[Character], O_TOTALPRICE: Rep[Double], O_ORDERDATE: Rep[Long], O_ORDERPRIORITY: Rep[OptimalString], O_CLERK: Rep[OptimalString], O_SHIPPRIORITY: Rep[Int], O_COMMENT: Rep[OptimalString]): Rep[ORDERSRecord] = ORDERSRecordNew(O_ORDERKEY, O_CUSTKEY, O_ORDERSTATUS, O_TOTALPRICE, O_ORDERDATE, O_ORDERPRIORITY, O_CLERK, O_SHIPPRIORITY, O_COMMENT)
  def oRDERSRecordGetField(self: Rep[ORDERSRecord], key: Rep[String]): Rep[Option[Any]] = ORDERSRecordGetField(self, key)
  def oRDERSRecord_Field_O_COMMENT(self: Rep[ORDERSRecord]): Rep[OptimalString] = ORDERSRecord_Field_O_COMMENT(self)
  def oRDERSRecord_Field_O_SHIPPRIORITY(self: Rep[ORDERSRecord]): Rep[Int] = ORDERSRecord_Field_O_SHIPPRIORITY(self)
  def oRDERSRecord_Field_O_CLERK(self: Rep[ORDERSRecord]): Rep[OptimalString] = ORDERSRecord_Field_O_CLERK(self)
  def oRDERSRecord_Field_O_ORDERPRIORITY(self: Rep[ORDERSRecord]): Rep[OptimalString] = ORDERSRecord_Field_O_ORDERPRIORITY(self)
  def oRDERSRecord_Field_O_ORDERDATE(self: Rep[ORDERSRecord]): Rep[Long] = ORDERSRecord_Field_O_ORDERDATE(self)
  def oRDERSRecord_Field_O_TOTALPRICE(self: Rep[ORDERSRecord]): Rep[Double] = ORDERSRecord_Field_O_TOTALPRICE(self)
  def oRDERSRecord_Field_O_ORDERSTATUS(self: Rep[ORDERSRecord]): Rep[Character] = ORDERSRecord_Field_O_ORDERSTATUS(self)
  def oRDERSRecord_Field_O_CUSTKEY(self: Rep[ORDERSRecord]): Rep[Int] = ORDERSRecord_Field_O_CUSTKEY(self)
  def oRDERSRecord_Field_O_ORDERKEY(self: Rep[ORDERSRecord]): Rep[Int] = ORDERSRecord_Field_O_ORDERKEY(self)
  type ORDERSRecord = ch.epfl.data.legobase.queryengine.TPCHRelations.ORDERSRecord
  case object ORDERSRecordType extends TypeRep[ORDERSRecord] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = ORDERSRecordType
    val name = "ORDERSRecord"
    val typeArguments = Nil
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[ORDERSRecord]
  }
  implicit val typeORDERSRecord = ORDERSRecordType
}
trait ORDERSRecordImplicits { this: ORDERSRecordComponent =>
  // Add implicit conversions here!
}
trait ORDERSRecordImplementations { self: DeepDSL =>

}
trait ORDERSRecordComponent extends ORDERSRecordOps with ORDERSRecordImplicits { self: DeepDSL => }

trait OptimalStringOps extends Base { this: DeepDSL =>
  implicit class OptimalStringRep(self: Rep[OptimalString]) {
    def equals(o: Rep[Any]): Rep[Boolean] = optimalStringEquals(self, o)
    def apply(i: Rep[Int]): Rep[Byte] = optimalStringApply(self, i)
    def startsWith(o: Rep[OptimalString]): Rep[Boolean] = optimalStringStartsWith(self, o)
    def containsSlice(o: Rep[OptimalString]): Rep[Boolean] = optimalStringContainsSlice(self, o)
    def endsWith(o: Rep[OptimalString]): Rep[Boolean] = optimalStringEndsWith(self, o)
    def slice(start: Rep[Int], end: Rep[Int]): Rep[OptimalString] = optimalStringSlice(self, start, end)
    def indexOfSlice(o: Rep[OptimalString], i: Rep[Int]): Rep[Int] = optimalStringIndexOfSlice(self, o, i)
    def diff(o: Rep[OptimalString]): Rep[Int] = optimalStringDiff(self, o)
    def compare(o: Rep[OptimalString]): Rep[Int] = optimalStringCompare(self, o)
    def ===(o: Rep[OptimalString]): Rep[Boolean] = optimalString$eq$eq$eq(self, o)
    def =!=(o: Rep[OptimalString]): Rep[Boolean] = optimalString$eq$bang$eq(self, o)
    def string: Rep[String] = optimalStringString(self)
    def zip(o: Rep[OptimalString]): Rep[Array[Tuple2[Byte, Byte]]] = optimalStringZip(self, o)
    def foldLeft(c: Rep[Int])(f: Rep[((Int, Byte) => Int)]): Rep[Int] = optimalStringFoldLeft(self, c, f)
    def data: Rep[Array[Byte]] = optimalString_Field_Data(self)
  }
  object OptimalString {
    def apply(data: Rep[Array[Byte]]): Rep[OptimalString] = optimalStringApplyObject(data)
    def default: Rep[OptimalString] = optimalStringDefaultObject()
  }
  // constructors
  def __newOptimalString(data: Rep[Array[Byte]]): Rep[OptimalString] = optimalStringNew(data)
  // case classes
  case class OptimalStringNew(data: Rep[Array[Byte]]) extends ConstructorDef[OptimalString](List(), "OptimalString", List(List(data))) {
    override def curriedConstructor = (copy _)
  }

  case class OptimalStringEquals(self: Rep[OptimalString], o: Rep[Any]) extends FunctionDef[Boolean](Some(self), "equals", List(List(o))) {
    override def curriedConstructor = (copy _).curried
  }

  case class OptimalStringApply(self: Rep[OptimalString], i: Rep[Int]) extends FunctionDef[Byte](Some(self), "apply", List(List(i))) {
    override def curriedConstructor = (copy _).curried
  }

  case class OptimalStringStartsWith(self: Rep[OptimalString], o: Rep[OptimalString]) extends FunctionDef[Boolean](Some(self), "startsWith", List(List(o))) {
    override def curriedConstructor = (copy _).curried
  }

  case class OptimalStringContainsSlice(self: Rep[OptimalString], o: Rep[OptimalString]) extends FunctionDef[Boolean](Some(self), "containsSlice", List(List(o))) {
    override def curriedConstructor = (copy _).curried
  }

  case class OptimalStringEndsWith(self: Rep[OptimalString], o: Rep[OptimalString]) extends FunctionDef[Boolean](Some(self), "endsWith", List(List(o))) {
    override def curriedConstructor = (copy _).curried
  }

  case class OptimalStringSlice(self: Rep[OptimalString], start: Rep[Int], end: Rep[Int]) extends FunctionDef[OptimalString](Some(self), "slice", List(List(start, end))) {
    override def curriedConstructor = (copy _).curried
  }

  case class OptimalStringIndexOfSlice(self: Rep[OptimalString], o: Rep[OptimalString], i: Rep[Int]) extends FunctionDef[Int](Some(self), "indexOfSlice", List(List(o, i))) {
    override def curriedConstructor = (copy _).curried
  }

  case class OptimalStringDiff(self: Rep[OptimalString], o: Rep[OptimalString]) extends FunctionDef[Int](Some(self), "diff", List(List(o))) {
    override def curriedConstructor = (copy _).curried
  }

  case class OptimalStringCompare(self: Rep[OptimalString], o: Rep[OptimalString]) extends FunctionDef[Int](Some(self), "compare", List(List(o))) {
    override def curriedConstructor = (copy _).curried
  }

  case class OptimalString$eq$eq$eq(self: Rep[OptimalString], o: Rep[OptimalString]) extends FunctionDef[Boolean](Some(self), "===", List(List(o))) {
    override def curriedConstructor = (copy _).curried
  }

  case class OptimalString$eq$bang$eq(self: Rep[OptimalString], o: Rep[OptimalString]) extends FunctionDef[Boolean](Some(self), "=!=", List(List(o))) {
    override def curriedConstructor = (copy _).curried
  }

  case class OptimalStringString(self: Rep[OptimalString]) extends FunctionDef[String](Some(self), "string", List()) {
    override def curriedConstructor = (copy _)
  }

  case class OptimalStringZip(self: Rep[OptimalString], o: Rep[OptimalString]) extends FunctionDef[Array[Tuple2[Byte, Byte]]](Some(self), "zip", List(List(o))) {
    override def curriedConstructor = (copy _).curried
  }

  case class OptimalStringFoldLeft(self: Rep[OptimalString], c: Rep[Int], f: Rep[((Int, Byte) => Int)]) extends FunctionDef[Int](Some(self), "foldLeft", List(List(c), List(f))) {
    override def curriedConstructor = (copy _).curried
  }

  case class OptimalString_Field_Data(self: Rep[OptimalString]) extends FieldDef[Array[Byte]](self, "data") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  case class OptimalStringApplyObject(data: Rep[Array[Byte]]) extends FunctionDef[OptimalString](None, "OptimalString.apply", List(List(data))) {
    override def curriedConstructor = (copy _)
  }

  case class OptimalStringDefaultObject() extends FunctionDef[OptimalString](None, "OptimalString.default", List()) {
    override def curriedConstructor = (x: Any) => copy()
  }

  // method definitions
  def optimalStringNew(data: Rep[Array[Byte]]): Rep[OptimalString] = OptimalStringNew(data)
  def optimalStringEquals(self: Rep[OptimalString], o: Rep[Any]): Rep[Boolean] = OptimalStringEquals(self, o)
  def optimalStringApply(self: Rep[OptimalString], i: Rep[Int]): Rep[Byte] = OptimalStringApply(self, i)
  def optimalStringStartsWith(self: Rep[OptimalString], o: Rep[OptimalString]): Rep[Boolean] = OptimalStringStartsWith(self, o)
  def optimalStringContainsSlice(self: Rep[OptimalString], o: Rep[OptimalString]): Rep[Boolean] = OptimalStringContainsSlice(self, o)
  def optimalStringEndsWith(self: Rep[OptimalString], o: Rep[OptimalString]): Rep[Boolean] = OptimalStringEndsWith(self, o)
  def optimalStringSlice(self: Rep[OptimalString], start: Rep[Int], end: Rep[Int]): Rep[OptimalString] = OptimalStringSlice(self, start, end)
  def optimalStringIndexOfSlice(self: Rep[OptimalString], o: Rep[OptimalString], i: Rep[Int]): Rep[Int] = OptimalStringIndexOfSlice(self, o, i)
  def optimalStringDiff(self: Rep[OptimalString], o: Rep[OptimalString]): Rep[Int] = OptimalStringDiff(self, o)
  def optimalStringCompare(self: Rep[OptimalString], o: Rep[OptimalString]): Rep[Int] = OptimalStringCompare(self, o)
  def optimalString$eq$eq$eq(self: Rep[OptimalString], o: Rep[OptimalString]): Rep[Boolean] = OptimalString$eq$eq$eq(self, o)
  def optimalString$eq$bang$eq(self: Rep[OptimalString], o: Rep[OptimalString]): Rep[Boolean] = OptimalString$eq$bang$eq(self, o)
  def optimalStringString(self: Rep[OptimalString]): Rep[String] = OptimalStringString(self)
  def optimalStringZip(self: Rep[OptimalString], o: Rep[OptimalString]): Rep[Array[Tuple2[Byte, Byte]]] = OptimalStringZip(self, o)
  def optimalStringFoldLeft(self: Rep[OptimalString], c: Rep[Int], f: Rep[((Int, Byte) => Int)]): Rep[Int] = OptimalStringFoldLeft(self, c, f)
  def optimalString_Field_Data(self: Rep[OptimalString]): Rep[Array[Byte]] = OptimalString_Field_Data(self)
  def optimalStringApplyObject(data: Rep[Array[Byte]]): Rep[OptimalString] = OptimalStringApplyObject(data)
  def optimalStringDefaultObject(): Rep[OptimalString] = OptimalStringDefaultObject()
  type OptimalString = ch.epfl.data.pardis.shallow.OptimalString
  case object OptimalStringType extends TypeRep[OptimalString] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = OptimalStringType
    val name = "OptimalString"
    val typeArguments = Nil

    val typeTag = scala.reflect.runtime.universe.typeTag[OptimalString]
  }
  implicit val typeOptimalString = OptimalStringType
}
trait OptimalStringImplicits { this: OptimalStringComponent =>
  // Add implicit conversions here!
}
trait OptimalStringImplementations { self: DeepDSL =>

}
trait OptimalStringComponent extends OptimalStringOps with OptimalStringImplicits { self: DeepDSL => }

trait K2DBScannerOps extends Base { this: DeepDSL =>
  implicit class K2DBScannerRep(self: Rep[K2DBScanner]) {
    def next_int(): Rep[Int] = k2DBScannerNext_int(self)
    def next_double(): Rep[Double] = k2DBScannerNext_double(self)
    def next_char(): Rep[Char] = k2DBScannerNext_char(self)
    def next(buf: Rep[Array[Byte]])(implicit overload1: Overloaded1): Rep[Int] = k2DBScannerNext1(self, buf)
    def next(buf: Rep[Array[Byte]], offset: Rep[Int])(implicit overload2: Overloaded2): Rep[Int] = k2DBScannerNext2(self, buf, offset)
    def next_date: Rep[Long] = k2DBScannerNext_date(self)
    def hasNext(): Rep[Boolean] = k2DBScannerHasNext(self)
    def delimiter_=(x$1: Rep[Char]): Rep[Unit] = k2DBScanner_Field_Delimiter_$eq(self, x$1)
    def delimiter: Rep[Char] = k2DBScanner_Field_Delimiter(self)
    def intDigits_=(x$1: Rep[Int]): Rep[Unit] = k2DBScanner_Field_IntDigits_$eq(self, x$1)
    def intDigits: Rep[Int] = k2DBScanner_Field_IntDigits(self)
    def byteRead_=(x$1: Rep[Int]): Rep[Unit] = k2DBScanner_Field_ByteRead_$eq(self, x$1)
    def byteRead: Rep[Int] = k2DBScanner_Field_ByteRead(self)
    def filename: Rep[String] = k2DBScanner_Field_Filename(self)
  }
  object K2DBScanner {

  }
  // constructors
  def __newK2DBScanner(filename: Rep[String]): Rep[K2DBScanner] = k2DBScannerNew(filename)
  // case classes
  case class K2DBScannerNew(filename: Rep[String]) extends ConstructorDef[K2DBScanner](List(), "K2DBScanner", List(List(filename))) {
    override def curriedConstructor = (copy _)
  }

  case class K2DBScannerNext_int(self: Rep[K2DBScanner]) extends FunctionDef[Int](Some(self), "next_int", List(List())) {
    override def curriedConstructor = (copy _)
  }

  case class K2DBScannerNext_double(self: Rep[K2DBScanner]) extends FunctionDef[Double](Some(self), "next_double", List(List())) {
    override def curriedConstructor = (copy _)
  }

  case class K2DBScannerNext_char(self: Rep[K2DBScanner]) extends FunctionDef[Char](Some(self), "next_char", List(List())) {
    override def curriedConstructor = (copy _)
  }

  case class K2DBScannerNext1(self: Rep[K2DBScanner], buf: Rep[Array[Byte]]) extends FunctionDef[Int](Some(self), "next", List(List(buf))) {
    override def curriedConstructor = (copy _).curried
  }

  case class K2DBScannerNext2(self: Rep[K2DBScanner], buf: Rep[Array[Byte]], offset: Rep[Int]) extends FunctionDef[Int](Some(self), "next", List(List(buf, offset))) {
    override def curriedConstructor = (copy _).curried
  }

  case class K2DBScannerNext_date(self: Rep[K2DBScanner]) extends FunctionDef[Long](Some(self), "next_date", List()) {
    override def curriedConstructor = (copy _)
  }

  case class K2DBScannerHasNext(self: Rep[K2DBScanner]) extends FunctionDef[Boolean](Some(self), "hasNext", List(List())) {
    override def curriedConstructor = (copy _)
  }

  case class K2DBScanner_Field_Delimiter_$eq(self: Rep[K2DBScanner], x$1: Rep[Char]) extends FieldSetter[Char](self, "delimiter", x$1) {
    override def curriedConstructor = (copy _).curried
  }

  case class K2DBScanner_Field_Delimiter(self: Rep[K2DBScanner]) extends FieldGetter[Char](self, "delimiter") {
    override def curriedConstructor = (copy _)
  }

  case class K2DBScanner_Field_IntDigits_$eq(self: Rep[K2DBScanner], x$1: Rep[Int]) extends FieldSetter[Int](self, "intDigits", x$1) {
    override def curriedConstructor = (copy _).curried
  }

  case class K2DBScanner_Field_IntDigits(self: Rep[K2DBScanner]) extends FieldGetter[Int](self, "intDigits") {
    override def curriedConstructor = (copy _)
  }

  case class K2DBScanner_Field_ByteRead_$eq(self: Rep[K2DBScanner], x$1: Rep[Int]) extends FieldSetter[Int](self, "byteRead", x$1) {
    override def curriedConstructor = (copy _).curried
  }

  case class K2DBScanner_Field_ByteRead(self: Rep[K2DBScanner]) extends FieldGetter[Int](self, "byteRead") {
    override def curriedConstructor = (copy _)
  }

  case class K2DBScanner_Field_Filename(self: Rep[K2DBScanner]) extends FieldDef[String](self, "filename") {
    override def curriedConstructor = (copy _)
    override def isPure = true

  }

  // method definitions
  def k2DBScannerNew(filename: Rep[String]): Rep[K2DBScanner] = K2DBScannerNew(filename)
  def k2DBScannerNext_int(self: Rep[K2DBScanner]): Rep[Int] = K2DBScannerNext_int(self)
  def k2DBScannerNext_double(self: Rep[K2DBScanner]): Rep[Double] = K2DBScannerNext_double(self)
  def k2DBScannerNext_char(self: Rep[K2DBScanner]): Rep[Char] = K2DBScannerNext_char(self)
  def k2DBScannerNext1(self: Rep[K2DBScanner], buf: Rep[Array[Byte]]): Rep[Int] = K2DBScannerNext1(self, buf)
  def k2DBScannerNext2(self: Rep[K2DBScanner], buf: Rep[Array[Byte]], offset: Rep[Int]): Rep[Int] = K2DBScannerNext2(self, buf, offset)
  def k2DBScannerNext_date(self: Rep[K2DBScanner]): Rep[Long] = K2DBScannerNext_date(self)
  def k2DBScannerHasNext(self: Rep[K2DBScanner]): Rep[Boolean] = K2DBScannerHasNext(self)
  def k2DBScanner_Field_Delimiter_$eq(self: Rep[K2DBScanner], x$1: Rep[Char]): Rep[Unit] = K2DBScanner_Field_Delimiter_$eq(self, x$1)
  def k2DBScanner_Field_Delimiter(self: Rep[K2DBScanner]): Rep[Char] = K2DBScanner_Field_Delimiter(self)
  def k2DBScanner_Field_IntDigits_$eq(self: Rep[K2DBScanner], x$1: Rep[Int]): Rep[Unit] = K2DBScanner_Field_IntDigits_$eq(self, x$1)
  def k2DBScanner_Field_IntDigits(self: Rep[K2DBScanner]): Rep[Int] = K2DBScanner_Field_IntDigits(self)
  def k2DBScanner_Field_ByteRead_$eq(self: Rep[K2DBScanner], x$1: Rep[Int]): Rep[Unit] = K2DBScanner_Field_ByteRead_$eq(self, x$1)
  def k2DBScanner_Field_ByteRead(self: Rep[K2DBScanner]): Rep[Int] = K2DBScanner_Field_ByteRead(self)
  def k2DBScanner_Field_Filename(self: Rep[K2DBScanner]): Rep[String] = K2DBScanner_Field_Filename(self)
  type K2DBScanner = ch.epfl.data.legobase.storagemanager.K2DBScanner
  case object K2DBScannerType extends TypeRep[K2DBScanner] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = K2DBScannerType
    val name = "K2DBScanner"
    val typeArguments = Nil

    val typeTag = scala.reflect.runtime.universe.typeTag[K2DBScanner]
  }
  implicit val typeK2DBScanner = K2DBScannerType
}
trait K2DBScannerImplicits { this: K2DBScannerComponent =>
  // Add implicit conversions here!
}
trait K2DBScannerImplementations { self: DeepDSL =>

}
trait K2DBScannerComponent extends K2DBScannerOps with K2DBScannerImplicits { self: DeepDSL => }

trait WindowRecordOps extends Base { this: DeepDSL =>
  implicit class WindowRecordRep[B, C](self: Rep[WindowRecord[B, C]])(implicit typeB: TypeRep[B], typeC: TypeRep[C]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = windowRecordGetField[B, C](self, key)(typeB, typeC)
    def wnd: Rep[C] = windowRecord_Field_Wnd[B, C](self)(typeB, typeC)
    def key: Rep[B] = windowRecord_Field_Key[B, C](self)(typeB, typeC)
  }
  object WindowRecord {

  }
  // constructors
  def __newWindowRecord[B, C](key: Rep[B], wnd: Rep[C])(implicit typeB: TypeRep[B], typeC: TypeRep[C]): Rep[WindowRecord[B, C]] = windowRecordNew[B, C](key, wnd)(typeB, typeC)
  // case classes
  case class WindowRecordNew[B, C](key: Rep[B], wnd: Rep[C])(implicit val typeB: TypeRep[B], val typeC: TypeRep[C]) extends ConstructorDef[WindowRecord[B, C]](List(typeB, typeC), "WindowRecord", List(List(key, wnd))) {
    override def curriedConstructor = (copy[B, C] _).curried
  }

  case class WindowRecordGetField[B, C](self: Rep[WindowRecord[B, C]], key: Rep[String])(implicit val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy[B, C] _).curried
  }

  case class WindowRecord_Field_Wnd[B, C](self: Rep[WindowRecord[B, C]])(implicit val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[C](self, "wnd") {
    override def curriedConstructor = (copy[B, C] _)
    override def isPure = true

  }

  case class WindowRecord_Field_Key[B, C](self: Rep[WindowRecord[B, C]])(implicit val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[B](self, "key") {
    override def curriedConstructor = (copy[B, C] _)
    override def isPure = true

  }

  // method definitions
  def windowRecordNew[B, C](key: Rep[B], wnd: Rep[C])(implicit typeB: TypeRep[B], typeC: TypeRep[C]): Rep[WindowRecord[B, C]] = WindowRecordNew[B, C](key, wnd)
  def windowRecordGetField[B, C](self: Rep[WindowRecord[B, C]], key: Rep[String])(implicit typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Option[Any]] = WindowRecordGetField[B, C](self, key)
  def windowRecord_Field_Wnd[B, C](self: Rep[WindowRecord[B, C]])(implicit typeB: TypeRep[B], typeC: TypeRep[C]): Rep[C] = WindowRecord_Field_Wnd[B, C](self)
  def windowRecord_Field_Key[B, C](self: Rep[WindowRecord[B, C]])(implicit typeB: TypeRep[B], typeC: TypeRep[C]): Rep[B] = WindowRecord_Field_Key[B, C](self)
  type WindowRecord[B, C] = ch.epfl.data.legobase.queryengine.WindowRecord[B, C]
  case class WindowRecordType[B, C](typeB: TypeRep[B], typeC: TypeRep[C]) extends TypeRep[WindowRecord[B, C]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = WindowRecordType(newArguments(0).asInstanceOf[TypeRep[_]], newArguments(1).asInstanceOf[TypeRep[_]])
    private implicit val tagB = typeB.typeTag
    private implicit val tagC = typeC.typeTag
    val name = s"WindowRecord[${typeB.name}, ${typeC.name}]"
    val typeArguments = List(typeB, typeC)
    override val isRecord = true
    val typeTag = scala.reflect.runtime.universe.typeTag[WindowRecord[B, C]]
  }
  implicit def typeWindowRecord[B: TypeRep, C: TypeRep] = WindowRecordType(implicitly[TypeRep[B]], implicitly[TypeRep[C]])
}
trait WindowRecordImplicits { this: WindowRecordComponent =>
  // Add implicit conversions here!
}
trait WindowRecordImplementations { self: DeepDSL =>

}
trait WindowRecordComponent extends WindowRecordOps with WindowRecordImplicits { self: DeepDSL => }

trait DeepDSL extends OperatorsComponent with AGGRecordComponent with WindowRecordComponent with CharacterComponent
  with DoubleComponent with IntComponent with LongComponent with ArrayComponent
  with GroupByClassComponent
  with Q3GRPRecordComponent
  with LINEITEMRecordComponent
  with SUPPLIERRecordComponent
  with PARTSUPPRecordComponent
  with REGIONRecordComponent
  with NATIONRecordComponent
  with PARTRecordComponent
  with CUSTOMERRecordComponent
  with ORDERSRecordComponent
  with OptimalStringComponent
  with K2DBScannerComponent with IntegerComponent
  with BooleanComponent with HashMapComponent with SetComponent with TreeSetComponent
  with DefaultEntryComponent with ArrayBufferComponent with ManualLiftedLegoBase

