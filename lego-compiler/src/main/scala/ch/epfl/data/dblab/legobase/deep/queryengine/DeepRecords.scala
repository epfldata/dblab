/* Generated by Purgatory 2014-2016 */

package ch.epfl.data.dblab.legobase.deep.queryengine

import ch.epfl.data.sc.pardis
import pardis.ir._
import pardis.types.PardisTypeImplicits._
import pardis.effects._
import pardis.deep._
import pardis.deep.scalalib._
import pardis.deep.scalalib.collection._
import pardis.deep.scalalib.io._

import ch.epfl.data.sc.pardis.quasi.anf.{ BaseExt, BaseExtIR }
import ch.epfl.data.sc.pardis.quasi.TypeParameters.MaybeParamTag

trait AGGRecordOps extends Base {
  // Type representation
  val AGGRecordType = AGGRecordIRs.AGGRecordType
  type AGGRecordType[B] = AGGRecordIRs.AGGRecordType[B]
  implicit def typeAGGRecord[B: TypeRep]: TypeRep[AGGRecord[B]] = AGGRecordType(implicitly[TypeRep[B]])
  implicit class AGGRecordRep[B](self: Rep[AGGRecord[B]])(implicit typeB: TypeRep[B]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = aGGRecordGetField[B](self, key)(typeB)
    def aggs: Rep[Array[Double]] = aGGRecord_Field_Aggs[B](self)(typeB)
    def key: Rep[B] = aGGRecord_Field_Key[B](self)(typeB)
  }
  object AGGRecord {
    def apply[B](key: Rep[B], aggs: Rep[Array[Double]])(implicit typeB: TypeRep[B]): Rep[AGGRecord[B]] = aGGRecordApplyObject[B](key, aggs)(typeB)
  }
  // constructors
  def __newAGGRecord[B](key: Rep[B], aggs: Rep[Array[Double]])(implicit typeB: TypeRep[B]): Rep[AGGRecord[B]] = aGGRecordNew[B](key, aggs)(typeB)
  // IR defs
  val AGGRecordNew = AGGRecordIRs.AGGRecordNew
  type AGGRecordNew[B] = AGGRecordIRs.AGGRecordNew[B]
  val AGGRecordGetField = AGGRecordIRs.AGGRecordGetField
  type AGGRecordGetField[B] = AGGRecordIRs.AGGRecordGetField[B]
  val AGGRecord_Field_Aggs = AGGRecordIRs.AGGRecord_Field_Aggs
  type AGGRecord_Field_Aggs[B] = AGGRecordIRs.AGGRecord_Field_Aggs[B]
  val AGGRecord_Field_Key = AGGRecordIRs.AGGRecord_Field_Key
  type AGGRecord_Field_Key[B] = AGGRecordIRs.AGGRecord_Field_Key[B]
  // method definitions
  def aGGRecordNew[B](key: Rep[B], aggs: Rep[Array[Double]])(implicit typeB: TypeRep[B]): Rep[AGGRecord[B]] = AGGRecordNew[B](key, aggs)
  def aGGRecordGetField[B](self: Rep[AGGRecord[B]], key: Rep[String])(implicit typeB: TypeRep[B]): Rep[Option[Any]] = AGGRecordGetField[B](self, key)
  def aGGRecord_Field_Aggs[B](self: Rep[AGGRecord[B]])(implicit typeB: TypeRep[B]): Rep[Array[Double]] = AGGRecord_Field_Aggs[B](self)
  def aGGRecord_Field_Key[B](self: Rep[AGGRecord[B]])(implicit typeB: TypeRep[B]): Rep[B] = AGGRecord_Field_Key[B](self)
  def aGGRecordApplyObject[B](key: Rep[B], aggs: Rep[Array[Double]])(implicit typeB: TypeRep[B]): Rep[AGGRecord[B]] = {
    __newAGGRecord[B](key, aggs)
  }
  type AGGRecord[B] = ch.epfl.data.dblab.legobase.queryengine.AGGRecord[B]
}
object AGGRecordIRs extends Base {
  // Type representation
  case class AGGRecordType[B](typeB: TypeRep[B]) extends ch.epfl.data.sc.pardis.types.ReflectionType[AGGRecord[B]](scala.reflect.runtime.universe.typeOf[AGGRecord[Any]], List(typeB)) {
    override def isRecord = true
  }
  implicit def typeAGGRecord[B: TypeRep]: TypeRep[AGGRecord[B]] = AGGRecordType(implicitly[TypeRep[B]])
  // case classes
  case class AGGRecordNew[B](key: Rep[B], aggs: Rep[Array[Double]])(implicit val typeB: TypeRep[B]) extends ConstructorDef[AGGRecord[B]](List(typeB), "AGGRecord", List(List(key, aggs))) {
    override def curriedConstructor = (copy[B] _).curried
    override def isPure = true

  }

  case class AGGRecordGetField[B](self: Rep[AGGRecord[B]], key: Rep[String])(implicit val typeB: TypeRep[B]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy[B] _).curried
  }

  case class AGGRecord_Field_Aggs[B](self: Rep[AGGRecord[B]])(implicit val typeB: TypeRep[B]) extends FieldDef[Array[Double]](self, "aggs") {
    override def curriedConstructor = (copy[B] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Array[Double] = {
      val self = children(0).asInstanceOf[AGGRecord[B]]
      self.aggs
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class AGGRecord_Field_Key[B](self: Rep[AGGRecord[B]])(implicit val typeB: TypeRep[B]) extends FieldDef[B](self, "key") {
    override def curriedConstructor = (copy[B] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): B = {
      val self = children(0).asInstanceOf[AGGRecord[B]]
      self.key
    }
    override def partiallyEvaluable: Boolean = true

  }

  type AGGRecord[B] = ch.epfl.data.dblab.legobase.queryengine.AGGRecord[B]
}
trait AGGRecordImplicits extends AGGRecordOps {
  // Add implicit conversions here!
}
trait AGGRecordComponent extends AGGRecordOps with AGGRecordImplicits {}

trait AGGRecordPartialEvaluation extends AGGRecordComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def aGGRecord_Field_Aggs[B](self: Rep[AGGRecord[B]])(implicit typeB: TypeRep[B]): Rep[Array[Double]] = self match {
    case Def(node: AGGRecordNew[_]) => node.aggs
    case _                          => super.aGGRecord_Field_Aggs[B](self)(typeB)
  }
  override def aGGRecord_Field_Key[B](self: Rep[AGGRecord[B]])(implicit typeB: TypeRep[B]): Rep[B] = self match {
    case Def(node: AGGRecordNew[_]) => node.key
    case _                          => super.aGGRecord_Field_Key[B](self)(typeB)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}

// QUASI GENERATED CODE:

object AGGRecordQuasiNodes extends BaseExtIR {
  import AGGRecordIRs._
  // case classes
  case class AGGRecordNewExt[B](key: Rep[B], aggs: Rep[Array[Double]])(implicit val paramB: MaybeParamTag[B]) extends FunctionDef[AGGRecordNew[B], AGGRecord[B]] {
    override def nodeUnapply(t: AGGRecordNew[B]): Option[Product] = (AGGRecordNew.unapply(t): Option[Product]) map { r =>
      paramB.define(t.typeB)
      r
    }
  }
  case class AGGRecordGetFieldExt[B](self: Rep[AGGRecord[B]], key: Rep[String])(implicit val paramB: MaybeParamTag[B]) extends FunctionDef[AGGRecordGetField[B], Option[Any]] {
    override def nodeUnapply(t: AGGRecordGetField[B]): Option[Product] = (AGGRecordGetField.unapply(t): Option[Product]) map { r =>
      paramB.define(t.typeB)
      r
    }
  }
  case class AGGRecord_Field_AggsExt[B](self: Rep[AGGRecord[B]])(implicit val paramB: MaybeParamTag[B]) extends FunctionDef[AGGRecord_Field_Aggs[B], Array[Double]] {
    override def nodeUnapply(t: AGGRecord_Field_Aggs[B]): Option[Product] = (AGGRecord_Field_Aggs.unapply(t): Option[Product]) map { r =>
      paramB.define(t.typeB)
      r
    }
  }
  case class AGGRecord_Field_KeyExt[B](self: Rep[AGGRecord[B]])(implicit val paramB: MaybeParamTag[B]) extends FunctionDef[AGGRecord_Field_Key[B], B] {
    override def nodeUnapply(t: AGGRecord_Field_Key[B]): Option[Product] = (AGGRecord_Field_Key.unapply(t): Option[Product]) map { r =>
      paramB.define(t.typeB)
      r
    }
  }
  type AGGRecord[B] = ch.epfl.data.dblab.legobase.queryengine.AGGRecord[B]
}

trait AGGRecordExtOps extends BaseExt {

  import AGGRecordQuasiNodes._
  import ch.epfl.data.sc.pardis.quasi.OverloadHackObj._
  implicit class AGGRecordRep[B](self: Rep[AGGRecord[B]])(implicit paramB: MaybeParamTag[B]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = aGGRecordGetField[B](self, key)(paramB)
    def aggs: Rep[Array[Double]] = aGGRecord_Field_Aggs[B](self)(paramB)
    def key: Rep[B] = aGGRecord_Field_Key[B](self)(paramB)
  }
  object AGGRecord {
    def apply[B](key: Rep[B], aggs: Rep[Array[Double]])(implicit paramB: MaybeParamTag[B]): Rep[AGGRecord[B]] = aGGRecordApplyObject[B](key, aggs)(paramB)
  }
  // constructors
  def __newAGGRecord[B](key: Rep[B], aggs: Rep[Array[Double]])(implicit paramB: MaybeParamTag[B]): Rep[AGGRecord[B]] = aGGRecordNew[B](key, aggs)(paramB)

  // method definitions
  def aGGRecordApplyObject[B](key: Rep[B], aggs: Rep[Array[Double]])(implicit paramB: MaybeParamTag[B]): Rep[AGGRecord[B]] = { __newAGGRecord[B](key, aggs) }
  def aGGRecordNew[B](key: Rep[B], aggs: Rep[Array[Double]])(implicit paramB: MaybeParamTag[B]): Rep[AGGRecord[B]] = AGGRecordNewExt[B](key, aggs)
  def aGGRecordGetField[B](self: Rep[AGGRecord[B]], key: Rep[String])(implicit paramB: MaybeParamTag[B]): Rep[Option[Any]] = AGGRecordGetFieldExt[B](self, key)
  def aGGRecord_Field_Aggs[B](self: Rep[AGGRecord[B]])(implicit paramB: MaybeParamTag[B]): Rep[Array[Double]] = AGGRecord_Field_AggsExt[B](self)
  def aGGRecord_Field_Key[B](self: Rep[AGGRecord[B]])(implicit paramB: MaybeParamTag[B]): Rep[B] = AGGRecord_Field_KeyExt[B](self)
  type AGGRecord[B] = ch.epfl.data.dblab.legobase.queryengine.AGGRecord[B]
}

trait WindowRecordOps extends Base {
  // Type representation
  val WindowRecordType = WindowRecordIRs.WindowRecordType
  type WindowRecordType[B, C] = WindowRecordIRs.WindowRecordType[B, C]
  implicit def typeWindowRecord[B: TypeRep, C: TypeRep]: TypeRep[WindowRecord[B, C]] = WindowRecordType(implicitly[TypeRep[B]], implicitly[TypeRep[C]])
  implicit class WindowRecordRep[B, C](self: Rep[WindowRecord[B, C]])(implicit typeB: TypeRep[B], typeC: TypeRep[C]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = windowRecordGetField[B, C](self, key)(typeB, typeC)
    def wnd: Rep[C] = windowRecord_Field_Wnd[B, C](self)(typeB, typeC)
    def key: Rep[B] = windowRecord_Field_Key[B, C](self)(typeB, typeC)
  }
  object WindowRecord {
    def apply[B, C](key: Rep[B], wnd: Rep[C])(implicit typeB: TypeRep[B], typeC: TypeRep[C]): Rep[WindowRecord[B, C]] = windowRecordApplyObject[B, C](key, wnd)(typeB, typeC)
  }
  // constructors
  def __newWindowRecord[B, C](key: Rep[B], wnd: Rep[C])(implicit typeB: TypeRep[B], typeC: TypeRep[C]): Rep[WindowRecord[B, C]] = windowRecordNew[B, C](key, wnd)(typeB, typeC)
  // IR defs
  val WindowRecordNew = WindowRecordIRs.WindowRecordNew
  type WindowRecordNew[B, C] = WindowRecordIRs.WindowRecordNew[B, C]
  val WindowRecordGetField = WindowRecordIRs.WindowRecordGetField
  type WindowRecordGetField[B, C] = WindowRecordIRs.WindowRecordGetField[B, C]
  val WindowRecord_Field_Wnd = WindowRecordIRs.WindowRecord_Field_Wnd
  type WindowRecord_Field_Wnd[B, C] = WindowRecordIRs.WindowRecord_Field_Wnd[B, C]
  val WindowRecord_Field_Key = WindowRecordIRs.WindowRecord_Field_Key
  type WindowRecord_Field_Key[B, C] = WindowRecordIRs.WindowRecord_Field_Key[B, C]
  // method definitions
  def windowRecordNew[B, C](key: Rep[B], wnd: Rep[C])(implicit typeB: TypeRep[B], typeC: TypeRep[C]): Rep[WindowRecord[B, C]] = WindowRecordNew[B, C](key, wnd)
  def windowRecordGetField[B, C](self: Rep[WindowRecord[B, C]], key: Rep[String])(implicit typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Option[Any]] = WindowRecordGetField[B, C](self, key)
  def windowRecord_Field_Wnd[B, C](self: Rep[WindowRecord[B, C]])(implicit typeB: TypeRep[B], typeC: TypeRep[C]): Rep[C] = WindowRecord_Field_Wnd[B, C](self)
  def windowRecord_Field_Key[B, C](self: Rep[WindowRecord[B, C]])(implicit typeB: TypeRep[B], typeC: TypeRep[C]): Rep[B] = WindowRecord_Field_Key[B, C](self)
  def windowRecordApplyObject[B, C](key: Rep[B], wnd: Rep[C])(implicit typeB: TypeRep[B], typeC: TypeRep[C]): Rep[WindowRecord[B, C]] = {
    __newWindowRecord[B, C](key, wnd)
  }
  type WindowRecord[B, C] = ch.epfl.data.dblab.legobase.queryengine.WindowRecord[B, C]
}
object WindowRecordIRs extends Base {
  // Type representation
  case class WindowRecordType[B, C](typeB: TypeRep[B], typeC: TypeRep[C]) extends ch.epfl.data.sc.pardis.types.ReflectionType[WindowRecord[B, C]](scala.reflect.runtime.universe.typeOf[WindowRecord[Any, Any]], List(typeB, typeC)) {
    override def isRecord = true
  }
  implicit def typeWindowRecord[B: TypeRep, C: TypeRep]: TypeRep[WindowRecord[B, C]] = WindowRecordType(implicitly[TypeRep[B]], implicitly[TypeRep[C]])
  // case classes
  case class WindowRecordNew[B, C](key: Rep[B], wnd: Rep[C])(implicit val typeB: TypeRep[B], val typeC: TypeRep[C]) extends ConstructorDef[WindowRecord[B, C]](List(typeB, typeC), "WindowRecord", List(List(key, wnd))) {
    override def curriedConstructor = (copy[B, C] _).curried
    override def isPure = true

  }

  case class WindowRecordGetField[B, C](self: Rep[WindowRecord[B, C]], key: Rep[String])(implicit val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy[B, C] _).curried
  }

  case class WindowRecord_Field_Wnd[B, C](self: Rep[WindowRecord[B, C]])(implicit val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[C](self, "wnd") {
    override def curriedConstructor = (copy[B, C] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): C = {
      val self = children(0).asInstanceOf[WindowRecord[B, C]]
      self.wnd
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class WindowRecord_Field_Key[B, C](self: Rep[WindowRecord[B, C]])(implicit val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[B](self, "key") {
    override def curriedConstructor = (copy[B, C] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): B = {
      val self = children(0).asInstanceOf[WindowRecord[B, C]]
      self.key
    }
    override def partiallyEvaluable: Boolean = true

  }

  type WindowRecord[B, C] = ch.epfl.data.dblab.legobase.queryengine.WindowRecord[B, C]
}
trait WindowRecordImplicits extends WindowRecordOps {
  // Add implicit conversions here!
}
trait WindowRecordComponent extends WindowRecordOps with WindowRecordImplicits {}

trait WindowRecordPartialEvaluation extends WindowRecordComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def windowRecord_Field_Wnd[B, C](self: Rep[WindowRecord[B, C]])(implicit typeB: TypeRep[B], typeC: TypeRep[C]): Rep[C] = self match {
    case Def(node: WindowRecordNew[_, _]) => node.wnd
    case _                                => super.windowRecord_Field_Wnd[B, C](self)(typeB, typeC)
  }
  override def windowRecord_Field_Key[B, C](self: Rep[WindowRecord[B, C]])(implicit typeB: TypeRep[B], typeC: TypeRep[C]): Rep[B] = self match {
    case Def(node: WindowRecordNew[_, _]) => node.key
    case _                                => super.windowRecord_Field_Key[B, C](self)(typeB, typeC)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}

// QUASI GENERATED CODE:

object WindowRecordQuasiNodes extends BaseExtIR {
  import WindowRecordIRs._
  // case classes
  case class WindowRecordNewExt[B, C](key: Rep[B], wnd: Rep[C])(implicit val paramB: MaybeParamTag[B], val paramC: MaybeParamTag[C]) extends FunctionDef[WindowRecordNew[B, C], WindowRecord[B, C]] {
    override def nodeUnapply(t: WindowRecordNew[B, C]): Option[Product] = (WindowRecordNew.unapply(t): Option[Product]) map { r =>
      paramB.define(t.typeB)
      paramC.define(t.typeC)
      r
    }
  }
  case class WindowRecordGetFieldExt[B, C](self: Rep[WindowRecord[B, C]], key: Rep[String])(implicit val paramB: MaybeParamTag[B], val paramC: MaybeParamTag[C]) extends FunctionDef[WindowRecordGetField[B, C], Option[Any]] {
    override def nodeUnapply(t: WindowRecordGetField[B, C]): Option[Product] = (WindowRecordGetField.unapply(t): Option[Product]) map { r =>
      paramB.define(t.typeB)
      paramC.define(t.typeC)
      r
    }
  }
  case class WindowRecord_Field_WndExt[B, C](self: Rep[WindowRecord[B, C]])(implicit val paramB: MaybeParamTag[B], val paramC: MaybeParamTag[C]) extends FunctionDef[WindowRecord_Field_Wnd[B, C], C] {
    override def nodeUnapply(t: WindowRecord_Field_Wnd[B, C]): Option[Product] = (WindowRecord_Field_Wnd.unapply(t): Option[Product]) map { r =>
      paramB.define(t.typeB)
      paramC.define(t.typeC)
      r
    }
  }
  case class WindowRecord_Field_KeyExt[B, C](self: Rep[WindowRecord[B, C]])(implicit val paramB: MaybeParamTag[B], val paramC: MaybeParamTag[C]) extends FunctionDef[WindowRecord_Field_Key[B, C], B] {
    override def nodeUnapply(t: WindowRecord_Field_Key[B, C]): Option[Product] = (WindowRecord_Field_Key.unapply(t): Option[Product]) map { r =>
      paramB.define(t.typeB)
      paramC.define(t.typeC)
      r
    }
  }
  type WindowRecord[B, C] = ch.epfl.data.dblab.legobase.queryengine.WindowRecord[B, C]
}

trait WindowRecordExtOps extends BaseExt {

  import WindowRecordQuasiNodes._
  import ch.epfl.data.sc.pardis.quasi.OverloadHackObj._
  implicit class WindowRecordRep[B, C](self: Rep[WindowRecord[B, C]])(implicit paramB: MaybeParamTag[B], paramC: MaybeParamTag[C]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = windowRecordGetField[B, C](self, key)(paramB, paramC)
    def wnd: Rep[C] = windowRecord_Field_Wnd[B, C](self)(paramB, paramC)
    def key: Rep[B] = windowRecord_Field_Key[B, C](self)(paramB, paramC)
  }
  object WindowRecord {
    def apply[B, C](key: Rep[B], wnd: Rep[C])(implicit paramB: MaybeParamTag[B], paramC: MaybeParamTag[C]): Rep[WindowRecord[B, C]] = windowRecordApplyObject[B, C](key, wnd)(paramB, paramC)
  }
  // constructors
  def __newWindowRecord[B, C](key: Rep[B], wnd: Rep[C])(implicit paramB: MaybeParamTag[B], paramC: MaybeParamTag[C]): Rep[WindowRecord[B, C]] = windowRecordNew[B, C](key, wnd)(paramB, paramC)

  // method definitions
  def windowRecordApplyObject[B, C](key: Rep[B], wnd: Rep[C])(implicit paramB: MaybeParamTag[B], paramC: MaybeParamTag[C]): Rep[WindowRecord[B, C]] = { __newWindowRecord[B, C](key, wnd) }
  def windowRecordNew[B, C](key: Rep[B], wnd: Rep[C])(implicit paramB: MaybeParamTag[B], paramC: MaybeParamTag[C]): Rep[WindowRecord[B, C]] = WindowRecordNewExt[B, C](key, wnd)
  def windowRecordGetField[B, C](self: Rep[WindowRecord[B, C]], key: Rep[String])(implicit paramB: MaybeParamTag[B], paramC: MaybeParamTag[C]): Rep[Option[Any]] = WindowRecordGetFieldExt[B, C](self, key)
  def windowRecord_Field_Wnd[B, C](self: Rep[WindowRecord[B, C]])(implicit paramB: MaybeParamTag[B], paramC: MaybeParamTag[C]): Rep[C] = WindowRecord_Field_WndExt[B, C](self)
  def windowRecord_Field_Key[B, C](self: Rep[WindowRecord[B, C]])(implicit paramB: MaybeParamTag[B], paramC: MaybeParamTag[C]): Rep[B] = WindowRecord_Field_KeyExt[B, C](self)
  type WindowRecord[B, C] = ch.epfl.data.dblab.legobase.queryengine.WindowRecord[B, C]
}

